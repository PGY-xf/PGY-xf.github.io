<!DOCTYPE html>

<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>以太坊白皮书解析 [ Pandsflies ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

</head></html>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
          
          
          
          
          
          <a href="/about">Resume</a>
        
          
          
          
          
          
          <a href="/E-BOOK">E-book</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">以太坊白皮书解析</h1>
<article class="post markdown-style">
  <p>目录</p>
<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%AF%BC%E8%AF%BB%E6%A6%82%E5%BF%B5" target="_blank" rel="noopener">导读概念</a></li>
<li>历史沿革<ul>
<li>中本聪的理念<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E4%BD%9C%E4%B8%BA%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%AF%94%E7%89%B9%E5%B8%81" target="_blank" rel="noopener">作为状态转换系统的比特币</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%8C%96%E7%9F%BF" target="_blank" rel="noopener">挖矿</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E9%BB%98%E5%85%8B%E5%B0%94%E6%A0%91" target="_blank" rel="noopener">默克尔树</a></li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%85%B6%E5%AE%83%E7%9A%84%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">其它的区块链应用</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E8%84%9A%E6%9C%AC" target="_blank" rel="noopener">脚本</a></li>
</ul>
</li>
<li>以太坊<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%B4%A6%E6%88%B7" target="_blank" rel="noopener">以太坊账户</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%B6%88%E6%81%AF%E5%92%8C%E4%BA%A4%E6%98%93" target="_blank" rel="noopener">消息和交易</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">以太坊状态转换函数</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Cevm%E5%B1%82" target="_blank" rel="noopener">代码执行（EVM层）</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%92%8C%E6%8C%96%E7%9F%BF" target="_blank" rel="noopener">区块链和挖矿</a></li>
</ul>
</li>
<li>以太坊应用举例<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E4%BB%A4%E7%89%8C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">令牌系统</a></li>
<li>金融衍生品和价值稳定的货币<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%AF%B9%E5%86%B2%E5%90%88%E7%BA%A6" target="_blank" rel="noopener">对冲合约</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%8F%91%E8%A1%8C%E8%80%85%E8%83%8C%E4%B9%A6%E8%B5%84%E4%BA%A7%E4%B8%8E%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%B8%82%E5%9C%BA" target="_blank" rel="noopener">发行者背书资产与去中心化市场</a></li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E8%BA%AB%E4%BB%BD%E5%92%8C%E4%BF%A1%E8%AA%89%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">身份和信誉系统</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E5%AD%98%E5%82%A8" target="_blank" rel="noopener">去中心化存储</a></li>
<li>去中心化自治组织（ DAO）<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%BA%94%E7%94%A8" target="_blank" rel="noopener">进一步应用</a></li>
</ul>
</li>
</ul>
</li>
<li>相关杂项<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%94%B9%E8%BF%9B%E7%89%88%E5%B9%BD%E7%81%B5%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%AE%9E%E6%96%BD" target="_blank" rel="noopener">改进版幽灵协议的实施</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E8%B4%B9%E7%94%A8" target="_blank" rel="noopener">费用</a></li>
<li>计算和图灵完备<ul>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E9%80%89%E6%8B%A9%E5%9B%BE%E7%81%B5%E5%AE%8C%E5%A4%87" target="_blank" rel="noopener">选择图灵完备</a></li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E8%B4%A7%E5%B8%81%E5%92%8C%E5%8F%91%E8%A1%8C" target="_blank" rel="noopener">货币和发行</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E5%8F%91%E8%A1%8C%E5%88%86%E8%A7%A3" target="_blank" rel="noopener">发行分解</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%8C%96%E7%9F%BF%E7%9A%84%E4%B8%AD%E5%BF%83%E5%8C%96" target="_blank" rel="noopener">挖矿的中心化</a></li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%89%A9%E5%B1%95%E6%80%A7" target="_blank" rel="noopener">扩展性</a></li>
</ul>
</li>
<li><a href="https://www.cnblogs.com/whyaza/p/9686325.html#%E6%80%BB%E7%BB%93" target="_blank" rel="noopener">总结</a></li>
</ul>
<p>@</p>
<h1 id="导读概念"><a href="#导读概念" class="headerlink" title="导读概念"></a>导读概念</h1><p>以太坊中常见的概念：<br><strong>块：块是存储在区块链中的单个事务或数据片段。</strong><br><strong>区块链：区块链是一个不断增长的记录列表（“链”），称为块，称为块，按时间顺序链接并使用加密技术进行保护。</strong><br><strong>区块链网络：区块链网络和区块链是可互换使用的术语。它们代表了从结构本身到它所属网络的整个区块链。</strong><br><strong>权力下放：参与者共同合作以在不依赖中央机构的情况下验证交易的概念。</strong><br><strong>参与者：拥有区块链副本并验证网络中交易的客户。</strong><br><strong>时间戳：创建块的时间决定了它在区块链上的位置。</strong><br><strong>交易数据：要安全存储在块中的信息。</strong><br><strong>哈希：通过组合块本身内的所有内容（也称为数字指纹）生成的唯一代码。也可解读为从特定输入生成的计算字母和数字字符串的一种算法</strong><br><strong>Previous Hash：每个块在其哈希之前都有一个对块的引用。这就是区块链的独特之处，因为如果一个块被篡改，这个链接就会被破坏。</strong><br><strong>Genesis Block：创世块是区块链上的第一个区块，通常硬编码到区块链结构中。作为区块链的第一个区块，它没有前一个哈希的链接。</strong><br><strong>交易：区块链网络参与者之间的价值交换。</strong><br><strong>共识：同意区块链网络上的交易的过程的机制。</strong><br><strong>工作量证明：区块链中的一项安全功能。后续详细说明</strong><br><strong>矿工：计算工作证明以挖掘新区块的特殊参与者。</strong><br><strong>Nonce：矿工猜测的一个数字，当与块结合时产生一个可接受的哈希值。</strong><br><strong>最长链：最可信赖的链，在计算工作量时完成了最大量的计算工作。</strong></p>
<p><strong>以太坊是一个全新开放的区块链平台，它允许任何人在平台中建立和使用通过区块链技术运行的去中心化应用</strong><br><em>和比特比相同点：就像比特币一样，以太坊不受任何人控制，也不归任何人所有——它是一个开放源代码项目，由全球范围内的很多人共同创建。</em><br><em>和比特币的不同点：和比特币协议有所不同的是，以太坊的设计十分灵活，极具适应性。在以太坊平台上创立新的应用十分简便.</em></p>
<h1 id="历史沿革"><a href="#历史沿革" class="headerlink" title="历史沿革"></a>历史沿革</h1><p>去中心化早在几十年前就已经被提出-&gt;1980.1990匿名电子现金协议（仍然依赖于一个中心化的中介机构）-&gt;戴伟的 b-money 首次引入了通过解决计算难题和去中心化共识创造货币的思想(该建议并未给出如何实现去中心化共识的具体方法)<br>-&gt;2005 年，芬尼引入了“可重复使用的工作量证明机制”概念，它同时使用 b-money 的思想和 Adam Back提出的计算困难的哈希现金（ Hashcash）难题来创造密码学货币(仍然依赖于可信任的计算作为后端)</p>
<p>上述发展面临问题：<br>比特币以前的所有电子货币协议所遇到的主要障碍是，尽管对如何创建安全的拜占庭问题容错多方共识系统的研究已经历时多年，但是上述协议只解决了问题的一半。这些协议假设系统的所有参与者是已知的，并产生如“<strong>如果有 N 方参与到系统中，那么系统可以容忍 N/4 的恶意参与者</strong>”这样形式的安全边界。然而这个假设的问题在于，在匿名的情况下，<strong>系统设置的安全边界容易遭受女巫攻击</strong>，因为一个攻击者可以在一台服务器或者僵尸网络上创建数以千计的节点，从而单方面确保拥有多数份额。</p>
<p>PS:<em>如果网络中存在一个恶意节点，那么同一个恶意节点可以具有多重身份，就如电影&lt;女巫&gt;的女主角都可以分裂出16个身份，那么恶意节点比它还能分。这一分可好，原来需要备份到多个节点的数据被欺骗地备份到了同一个恶意节点（该恶意节点伪装成多重身份），这就是女巫攻击。</em></p>
<h2 id="中本聪的理念"><a href="#中本聪的理念" class="headerlink" title="中本聪的理念"></a>中本聪的理念</h2><p>将一个非常简单的基于节点的去中心化共识协议与工作量证明机制结合在一起。节点通过工作量证明机制获得参与到系统的权利，每十分钟将交易打包到“区块”中，从而创建出不断增长的区块链。拥有大量算力的节点有更大的影响力，<strong>但获得比整个网络更多的算力比创建一百万个节点困难得多。</strong> 尽管比特币的区块链模型很简陋，但是他的思路真的解决了上述的发展问题。实践证明它已经足够好用了，在未来五年，它将成为全世界两百个以上的货币和协议的基石。</p>
<h3 id="作为状态转换系统的比特币"><a href="#作为状态转换系统的比特币" class="headerlink" title="作为状态转换系统的比特币"></a>作为状态转换系统的比特币</h3><p><strong>比特币账本可以被认为是一个状态转换系统</strong>该系统包括所有现存的比特币所有权状态和“状态转换函数”。状态转换函数以当前状态和交易为输入，输出新的状态.<br><em>在标准的银行系统中，状态就是一个资产负债表，一个从 A 账户向 B 账户转账 X 美元的请求是一笔交易，状态转换函数将从 A 账户中减去 X 美元，向 B 账户增加 X 美元。如果 A 账户的余额小于 X 美元，状态转换函数就会返回错误提示。</em><br>状态转换函数原型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">APPLY(S,TX) &gt; S’ or ERROR</span><br></pre></td></tr></table></figure>

<p>具体如下状态转换函数如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">APPLY(&#123; Alice: $50, Bob: $50 &#125;,”send $20 from Alice to Bob”) = &#123; Alice:$30,Bob: $70 &#125;</span><br><span class="line">APPLY(&#123; Alice: $50, Bob: $50 &#125;,”send $70 from Alice to Bob”) = ERROR</span><br></pre></td></tr></table></figure>

<p>在比特币的设计中，并没有账户概念（这是后来才有的概念，HyperLedger 和Ethereum 一开始并没有采用 UTXO[Unspent Transaction Output]，现在前者已经切换回 UTXO，后者打算增加这个选项。）。</p>
<p>为了理解比特币的状态转换关系，需要对一下进行解释：<br>1.比特币系统的“状态”是所有已经被挖出的、没有花费的比特币(UTXO)的集合。<br>2.一笔交易包括一个或多个输入和一个或多个输出。<br>3.每个输出包含一个新的加入到状态中的 UTXO。</p>
<p>在比特币系统中，状态转换函数 APPLY(S,TX)-&gt;S‟大体上可以如下定义：</p>
<ol>
<li>交易的每个输入：<br>如果引用的 UTXO 不存在于现在的状态中（ S），返回错误提示 （防止交易的发送者花费不存在的比特币，联想银行系统的转换函数）<br>如果签名与 UTXO 所有者的签名不一致，返回错误提示（防止交易的发送者花费其他人的比特币。）</li>
<li>如果所有的 UTXO 输入面值总额小于所有的 UTXO 输出面值总额，返回错误提示（确保价值守恒。）</li>
<li>返回新状态 S‟,新状态 S‟中移除了所有的输入 UTXO，增加了所有的输出 UTXO。</li>
</ol>
<p>下面用图示加以解析：（图摘自币学院）<br>我们假设一个这样的场景：<br><em>张三挖到12.5 枚比特币。过了几天，他把其中 2.5 枚支付给李四。又过了几天，他和李四各出资 2.5 比特币凑成 5 比特币付给王五。</em><br>如果是基于账户的设计，张、李、王三人在数据库中各有一个账户，则他们三人的账户变化如下图所示：<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180921205253561-783971594.jpg" alt="img"><br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180921205255870-84543970.jpg" alt="img"><br>解释：<br>上图第一个交易 #1001 号交易是 coinbase 交易。比特币是矿工挖出来的。当一个矿机费尽九牛二虎之力找到一个合格的区块之后，它就获得一个特权，能够创造一个 coinbase 交易，在其中放入一笔新钱，并且在交易输出的收款人地址一栏，堂堂正正的写上自己的地址。<br>过了几天，张三打算付 2.5 个比特币给李四，张三就发起一#2001号交易，这个交易的资金来源项写着“#1001(1)”，也就是 #1001 号交易——张三挖出矿的那个 coinbase 交易——的第一项 UTXO。然后在本交易的交易输出 UTXO 项中，把2.5个比特币的收款人地址设为李四的地址。</p>
<p>请注意，这一笔交易必须将前面产生那一项 12.5 个比特币的输出项全部消耗，而由于张三只打算付给李四 2.5 个比特币，为了要消耗剩下的10比特币，他只好把剩余的那 10 个比特币支付给自己，这样才能符合输入与输出配平的规则。</p>
<p>再过几天，张三和李四打算AA制合起来给王五付 5 枚比特币。那么张三或李四发起 #3001 号交易，在交易输入部分，有两个资金来源，分别是#2001(1) 和 #2001(2)，代表第 #2001 号交易的第 (1) 和第 (2) 项 UTXO。然后在这个交易的输出部分里如法炮制，给王五5比特币，把张三剩下的 7.5 比特币发还给自己。以后王五若要再花他这5比特币，就必须在他的交易里注明资金的来源是 #3001(1)。</p>
<p>当我们说张三拥有 10 枚比特币的时候，我实际上是说，当前区块链账本中，有若干笔交易的 UTXO 项收款人写的是张三的地址，而这些 UTXO 项的数额总和是 10。要知道自己的一大堆地址里一共收了多少 UTXO，人是算不过来的，需要由比特币钱包代为跟踪计算。</p>
<p>以上即为 UTXO 的一个简要的介绍。</p>
<p>白皮书中做了一个简要的例子：</p>
<blockquote>
<p>假设 Alice 想给 Bob 发送 11.7BTC。事实上， Alice 不可能正好有 11.7BTC。假设，她能得到的最小数额比特币的方式是： 6+4+2=12。所以，她可以创建一笔有 3个输入， 2 个输出的交易。第一个输出的面值是 11.7BTC，所有者是 Bob（ Bob的比特币地址），第二个输出的面值是 0.3BTC，所有者是 Alice 自己，也就是找零。</p>
</blockquote>
<h3 id="挖矿"><a href="#挖矿" class="headerlink" title="挖矿"></a>挖矿</h3><p>我们想把比特币系统建成为去中心化的货币系统，为了确保每个人都同意交易的顺序，我们需要将<strong>状态转换系统与一个共识系统(这里指的是工作量机制)</strong>结合起来。<br><strong>比特币的去中心化共识进程要求网络中的节点不断尝试将交易打包成“区块”。</strong><br>网络被设计为大约每十分钟产生一个区块，每个区块包含<strong>一个时间戳、一个随机数（Nonce）、一个对上一个区块的引用（即哈希）和上一区块生成以来发生的所有交易列表。</strong><br>这样随着时间流逝就创建出了一个持续增长的区块链，它不断地更新，从而能够代表比特币账本的最新状态。</p>
<p>依照这个范式，检查一个区块是否有效的算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在且有效。</li>
<li>检查区块的时间戳是否晚于以前的区块的时间戳，而且早于未来 2 小时。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将上一个区块的最终状态赋于 S[0]。</li>
<li>假设 TX 是区块的交易列表，包含 n 笔交易。对于属于 0……n-1 的所有 i,进行状态转换 <strong>S[i+1] = APPLY(S[i],TX[i])</strong>。如果任何一笔交易 i 在状态转换中出错，退出程序，返回错误。</li>
<li>返回正确，状态 S[n]是这一区块的最终状态。</li>
</ol>
<p>另外，需要注意矿工将交易收录进区块的顺序。如果一个区块中有A、 B 两笔交易， B 花费的是 A 创建的 UTXO，如果 A 在 B 以前，这个区块是有效的，否则，这个区块是无效的。</p>
<p>“工作量证明”：对每个区块进行 SHA256 哈希处理，将得到的哈希视为长度为 256 比特的数值，该数值必须小于不断动态调整的目标数值。工作量证明的目的是使区块的创建变得困难，从而阻止女巫攻击者恶意重新生成区块链。因为 SHA256 是完全不可预测的伪随机函数，创建有效区块的唯一方法就是简单地不断试错，不断地增加随机数的数值，查看新的哈希数值是否小于目标数值。如果当前的目标数值是 2^192，就意味着平均需要尝试 2^64 次才能生成有效的区块。一般而言，比特币网络每隔 2016 个区块重新设定目标数值，保证平均每十分钟生成一个区块。为了对矿工的计算工作进行奖励，每一个成功生成区块的矿工有权在区块中包含一笔凭空发给他们自己 25BTC 的交易。另外，如果交易的输入大于输出，差额部分就作为“交易费用”付给矿工。顺便提一下，对矿工的奖励是比特币发行的唯一机制，创世状态中并没有比特币。</p>
<p>为了更好地理解挖矿的目的，让我们分析比特币网络出现恶意攻击者时会发生什么。因为比特币的密码学基础是非常安全的，所以攻击者会选择攻击没有被密码学直接保护的部分：交易顺序。攻击者的策略非常简单：</p>
<ol>
<li>向卖家发送 100BTC 购买商品（尤其是无需邮寄的电子商品）。</li>
<li>等待直至商品发出。</li>
<li>创建另一笔交易，将相同的 100BTC 发送给自己的账户。</li>
<li>使比特币网络相信发送给自己账户的交易是最先发出的。</li>
</ol>
<p>攻击的图示如下（自己画的，勿喷。。）：<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180922121827608-1665771128.jpg" alt="img"><br>一旦步骤（ 1）发生，几分钟后矿工将把这笔交易打包到区块，假设是第 270000个区块。大约一个小时以后，在此区块后面将会有五个区块，每个区块间接地指向这笔交易，从而确认这笔交易。这时卖家收到货款，并向买家发货。因为我们假设这是数字商品，攻击者可以即时收到货。现在，攻击者创建另一笔交易，将相同的 100BTC 发送到自己的账户。如果攻击者只是向全网广播这一消息，这一笔交易不会被处理。矿工会运行状态转换函数 APPLY(S,TX)，发现这笔交易将花费已经不在状态中的 UTXO。所以，<strong>攻击者会对区块链进行分叉，将第269999 个区块作为父区块重新生成第 270000 个区块，在此区块中用新的交易取代旧的交易。因为区块数据是不同的，这要求重新进行工作量证明</strong>。另外，<strong>因为攻击者生成的新的第 270000 个区块有不同的哈希，所以原来的第 270001 到第 270005的区块不指向它，因此原有的区块链和攻击者的新区块是完全分离的</strong>。在发生区块链分叉时，区块链长的分支被认为是诚实的区块链，合法的的矿工将会沿着原有的第 270005 区块后挖矿，只有攻击者一人在新的第 270000 区块后挖矿。攻击者为了使得他的区块链最长，他需要拥有比除了他以外的全网更多的算力来追赶（即 51%攻击）。也就是说，<strong>攻击者重新生成6个Nonce的速度和全网络计算的速度一定相比起来，是慢了很多的。</strong></p>
<h3 id="默克尔树"><a href="#默克尔树" class="headerlink" title="默克尔树"></a>默克尔树</h3><p>对于默克尔树的介绍如下：</p>
<blockquote>
<p>默克尔树是一种二叉树，由一组叶节点、一组中间节点和一个根节点构成。最下面的大量的叶节点包含基础数据，每个中间节点是它的两个子节点的哈希，根节点也是由它的两个子节点的哈希，代表了默克尔树的顶部。<strong>默克尔树的目的是允许区块的数据可以零散地传送</strong>：节点可以从一个源下载区块头，从另外的源下载与其有关的树的其它部分，而依然能够确认所有的数据都是正确的。之所以如此是因为哈希向上的扩散：如果一个恶意用户尝试在树的下部加入一个伪造的交易，所引起的改动将导致树的上层节点的改动，以及更上层节点的改动，最终导致根节点的改动以及区块哈希的改动，这样协议就会将其记录为一个完全不同的区块（几乎可以肯定是带着不正确的工作量证明的）。<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180922122445082-604196134.png" alt="img"><br>左：仅提供默克尔树（ Merkle tree）上的少量节点已经足够给出分支的合法证明。<br>右：任何对于默克尔树的任何部分进行改变的尝试都会最终导致链上某处的不一致。（图：摘自白皮书）</p>
</blockquote>
<p>比特币系统的一个重要的可扩展特性是：它的区块存储在多层次的数据结构中。<br><strong>一个区块的哈希实际上只是区块头的哈希</strong>，区块头是包含<em>时间戳、随机数、上个区块哈希和存储了所有的区块交易的默克尔树的根哈希的长度大约为 200 字节的一段数据。</em><br>默克尔树协议对比特币的长期持续性可以说是至关重要的。在 2014 年 4 月，比特币网络中的一个全节点-存储和处理所有区块的全部数据的节点-需要占用15GB 的内存空间，而且还以每个月超过 1GB 的速度增长。目前，这一存储空间对台式计算机来说尚可接受，但是手机已经负载不了如此巨大的数据了。未来只有商业机构和爱好者才会充当完整节点。简化支付确认（ SPV)协议允许另一种节点存在，这样的节点被成为“轻节点”，它下载区块头，使用区块头确认工作量证明，然后只下载与其交易相关的默克尔树“分支”。这使得轻节点只要下载整个区块链的一小部分，就可以安全地确定任何一笔比特币交易的状态和账户的当前余额。</p>
<h2 id="其它的区块链应用"><a href="#其它的区块链应用" class="headerlink" title="其它的区块链应用"></a>其它的区块链应用</h2><ul>
<li><p>域名币（ namecoin） - 创建于 2010 年，被称为去中心化的名称注册数据库。利用区块链解决账户重名问题。</p>
</li>
<li><p>彩色币（ Colored coins） - 彩色币的目的是为人们在比特币区块链上创建自己的数字货币，或者，在更重要的一般意义上的货币 – 数字令牌提供服务。</p>
<h3 id="元币（-Metacoins"><a href="#元币（-Metacoins" class="headerlink" title="元币（ Metacoins)"></a>元币（ Metacoins)</h3></li>
</ul>
<ol>
<li>采用了不同的状态转换函数 APPLY-&gt;为创建任意的、先进的不能在比特币系统中实现的密码学货币协议提供了一个简单的解决方法</li>
<li>建立共识困难</li>
<li>没有继承比特币可以进行简化确认支付（ SPV) 的特性<br>另外，我们预测去中心化共识技术的应用将会服从幂律分布，大多数的应用太小不足以保证自由区块链的安全，我们还注意到大量的去中心化应用，尤其是去中心化自治组织，需要进行应用之间的交互。</li>
</ol>
<h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>即使不对比特币协议进行扩展，它也能在一定程度上实现”智能合约”。比特币的UTXO 可以被不只一个公钥拥有，也可以被用基于堆栈的编程语言所编写的更加复杂的脚本所拥有。在这一模式下，花费这样的 UTXO，必须提供满足脚本的数据。事实上，基本的公钥所有权机制也是通过脚本实现的：脚本将椭圆曲线签名作为输入，验证交易和拥有这一 UTXO 的地址，如果验证成功，返回 1，否则返回 0。更加复杂的脚本用于其它不同的应用情况。例如，人们可以创建要求集齐三把私钥中的两把才能进行交易确认的脚本（多重签名），对公司账户、储蓄账户和某些商业代理来说，这种脚本是非常有用的。脚本也能用来对解决计算问题的用户发送奖励。<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180928191437694-1923178503.jpg" alt="img"></p>
<p>然而，比特币系统的脚本语言存在一些严重的限制：</p>
<ul>
<li><p>缺少图灵完备性 – 这就是说，尽管比特币脚本语言可以支持多种计算，但是它不能支持所有的计算。最主要的缺失是循环语句。不支持循环语句的目的是避免交易确认时出现无限循环。理论上，对于脚本程序员来说，这是可以克服的障碍，因为任何循环都可以用多次重复 if 语句的方式来模拟，但是这样做会导致脚本空间利用上的低效率，例如，实施一个替代的椭圆曲线签名算法可能将需要 256次重复的乘法，而每次都需要单独编码。</p>
</li>
<li><p>价值盲（ Value-blindness）。 UTXO 脚本不能为账户的取款额度提供精细的控制。例如，预言机合约（ oracle contract）的一个强大应用是对冲合约， A 和 B各自向对冲合约中发送价值 1000 美元的比特币， 30 天以后，脚本向 A 发送价值 1000 美元的比特币，向 B 发送剩余的比特币。虽然实现对冲合约需要一个预言机决定一比特币值多少美元，与现在完全中心化的解决方案相比，这一机制已经在减少信任和基础设施方面有了巨大的进步。然而，因为 UTXO是不可分割的，为实现此合约，唯一的方法是非常低效地采用许多有不同面值的UTXO并使预言机挑出正确的 UTXO 发送给 A 和 B。<br>ps:对冲合约</p>
<blockquote>
<p>例如：甲客户在2009年最后一个交易日在期货市场买开仓大豆1009合约100手；乙客户在2010年第一个交易日卖开仓大豆1009合约100手。次日在期货市场把甲客户把买进开仓的100手大豆合约做卖出平仓，乙客户把卖出开仓100手大豆合约做买入平仓。<br>甲乙双方互为交易对手交易仓单发生的平仓交易叫做对冲合约。</p>
</blockquote>
</li>
<li><p>缺少状态 – UTXO 只能是已花费或者未花费状态，这就没有给需要任何其它内部状态的多阶段合约或者脚本留出生存空间。这使得实现多阶段期权合约、去中心化的交换要约或者两阶段加密承诺协议（对确保计算奖励非常必要）非常困难。这也意味着 UTXO 只能用于建立简单的、一次性的合约，而不是例如去中心化组织这样的有着更加复杂的状态的合约，使得元协议难以实现。二元状态与价值盲结合在一起意味着另一个重要的应用-取款限额-是不可能实现的。<br>ps:<em>取款限额：央行规定人民币每天只能取5万以下，不含5万，5万以上就得预约。如果是美元，1万以上就需预约。</em></p>
</li>
<li><p>区块链盲（ Blockchain-blindness） - UTXO 看不到区块链的数据，例如随机数和上一个区块的哈希。这一缺陷剥夺了脚本语言所拥有的基于随机性的潜在价值，严重地限制了博彩等其它领域应用。</p>
</li>
</ul>
<p>基于以上，以太坊考察了在密码学货币上建立高级应用的三种方法：建立一个新的区块链，在比特币区块链上使用脚本，在比特币区块链上建立元币协议。<br>建立新区块链的方法可以自由地实现任意的特性，成本是开发时间和培育努力。使用脚本的方法非常容易实现和标准化，但是它的能力有限。元币协议尽管非常容易实现，但是存在扩展性差的缺陷。<br>在以太坊系统中，<strong>其目的是建立一个能够同时具有这三种模式的所有优势的通用框架。</strong></p>
<h1 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h1><p>以太坊的目的是基于脚本、竞争币和链上元协议（ on-chain meta-protocol）概念进行整合和提高，使得开发者能够创建任意的基于共识的、可扩展的、标准化的、特性完备的、易于开发的和协同的应用。以太坊通过建立终极的抽象的基础层-内置有图灵完备编程语言的区块链-使得任何人都能够创建合约和去中心化应用，并在其中设立他们自由定义的所有权规则、交易方式和状态转换函数。</p>
<h2 id="以太坊账户"><a href="#以太坊账户" class="headerlink" title="以太坊账户"></a>以太坊账户</h2><p>以太坊系统中，<strong>状态是由被称为“账户”（每个账户由一个 20 字节的地址）的对象和在两个账户之间转移价值和信息的状态转换构成的</strong>。以太坊的账户包含四个部分：</p>
<ul>
<li>随机数，用于确定每笔交易只能被处理一次的计数器</li>
<li>账户目前的以太币余额</li>
<li>账户的合约代码，如果有的话</li>
<li>账户的存储（默认为空）</li>
</ul>
<p>以太币（ Ether）是以太坊内部的主要加密燃料，用于支付交易费用。一般而言，以太坊有两种类型的账户：外部所有的账户（由私钥控制的）和合约账户（由合约代码控制）。外部所有的账户没有代码，人们可以通过创建和签名一笔交易从一个外部账户发送消息。每当合约账户收到一条消息，合约内部的代码就会被激活，允许它对内部存储进行读取和写入，和发送其它消息或者创建合约。</p>
<h2 id="消息和交易"><a href="#消息和交易" class="headerlink" title="消息和交易"></a>消息和交易</h2><p>以太坊的消息在某种程度上类似于比特币的交易，但是两者之间存在三点重要的不同。</p>
<ol>
<li>以太坊的消息可以由外部实体或者合约创建，然而比特币的交易只能从外部创建。</li>
<li>以太坊消息可以选择包含数据。</li>
<li>如果以太坊消息的接受者是合约账户，可以选择进行回应，这意味着以太坊消息也包含函数概念。</li>
</ol>
<p>以太坊中“交易”是指<strong>存储从外部账户发出的消息的签名数据包</strong>。交易包含消息的接收者、用于确认发送者的签名、以太币账户余额、要发送的数据和两个被称为STARTGAS 和 GASPRICE 的数值。<strong>为了防止代码的指数型爆炸和无限循环，每笔交易需要对执行代码所引发的计算步骤-包括初始消息和所有执行中引发的消息-做出限制。</strong> STARTGAS 就是限制， GASPRICE 是每一计算步骤需要支付矿工的费用。如果执行交易的过程中， “用完了燃料”，所有的状态改变恢复原状态，但是已经支付的交易费用不可收回了。如果执行交易中止时还剩余燃料，那么这些燃料将退还给发送者。创建合约有单独的交易类型和相应的消息类型；合约的地址是基于账号随机数和交易数据的哈希计算出来的。</p>
<p>为了较为深入的理解以上过程，下面简要的对此过程进行分析：(摘自 南京-菜根谭的博客)<br>设定有如下场景：假设发送者设置gas limit(STARTGAS)为50,000，gas price为20gwei。这就表示发送者愿意最多支付50,000*20gwei = 1,000,000,000,000,000 Wei = 0.001 Ether来执行此交易。<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180923105119720-2026520945.png" alt="img"></p>
<p>gas limit代表用户愿意花费在gas上的钱的最大值。如果在他们的账户余额中有足够的Ether来支付这个最大值费用，那么就没问题。在交易结束时任何未使用的gas都会被返回给发送者，以原始费率兑换。<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180923105145497-296738824.png" alt="img"></p>
<p>在发送者没有提供足够的gas来执行交易，那么交易执行就会出现“gas不足”然后被认为是无效的。在这种情况下，交易处理就会被终止以及所有已改变的状态将会被恢复，最后我们就又回到了交易之前的状态—完完全全的之前状态就像这笔交易从来没有发生。因为机器在耗尽gas之前还是为计算做出了努力，<br>所以理论上，将不会有任何的gas被返回给发送者。（这样就能防止恶意的无限交易）<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180923105334602-1164417125.png" alt="img"></p>
<p>这些gas的钱到底去了哪里？发送者在gas上花费的所有钱都发送给了“受益人”地址，通常情况下就是矿工的地址。因为矿工为了计算和验证交易做出了努力，所以矿工接收gas的费用作为奖励。<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180923105402899-800414845.png" alt="img"></p>
<p>消息机制的一个重要后果是以太坊的“头等公民”财产-合约与外部账户拥有同样权利，包括发送消息和创建其它合约的权利。这使得合约可以同时充当多个不同的角色，例如，用户可以使去中心化组织（一个合约）的一个成员成为一个中介账户（另一个合约），为一个偏执的使用定制的基于量子证明的兰波特签名（第三个合约）的个人和一个自身使用由五个私钥保证安全的账户（第四个合约）的共同签名实体提供居间服务。以太坊平台的强大之处在于去中心化的组织和代理合约不需要关心合约的每一参与方是什么类型的账户。</p>
<h2 id="以太坊状态转换函数"><a href="#以太坊状态转换函数" class="headerlink" title="以太坊状态转换函数"></a>以太坊状态转换函数</h2><p>以太坊的状态转换函数： APPLY(S,TX) -&gt; S’ ，可以定义如下：</p>
<ol>
<li>检查交易的格式是否正确（即有正确数值）、签名是否有效和随机数是否与发送者账户的随机数匹配。如否，返回错误。</li>
<li>计算交易费用:fee=STARTGAS * GASPRICE，并从签名中确定发送者的地址。从发送者的账户中减去交易费用和增加发送者的随机数。如果账户余额不足，返回错误。</li>
<li>设定初值 GAS = STARTGAS，并根据交易中的字节数减去一定量的燃料值。</li>
<li>从发送者的账户转移价值到接收者账户。如果接收账户还不存在，创建此账户。如果接收账户是一个合约，运行合约的代码，直到代码运行结束或者燃料用完。</li>
<li>如果因为发送者账户没有足够的钱或者代码执行耗尽燃料导致价值转移失败，恢复原来的状态，但是还需要支付交易费用，交易费用加至矿工账户。</li>
<li>否则，将所有剩余的燃料归还给发送者，消耗掉的燃料作为交易费用发送给矿工。</li>
</ol>
<p>白皮书中给的例子为：</p>
<blockquote>
<p>假设合约存储器开始时是空的，一个值为 10 以太，燃料为 2000，燃料价格为 0.001 以太并且两个数据字段值为[ 2, „CHARLIE‟ ] [3]的交易发送后，状态转换函数的处理过程如下：</p>
</blockquote>
<ol>
<li>检查交易是否有效、格式是否正确。</li>
<li>检查交易发送者至少有 2000*0.001=2 个以太币。如果有，从发送者账户中减去2 个以太币。</li>
<li>初始设定 gas=2000,假设交易长为 170 字节，每字节的费用是 5，减去 850，所以还剩 1150。</li>
<li>从发送者账户减去 10 个以太币，为合约账户增加 10 个以太币。</li>
<li>运行代码。在这个合约中，运行代码很简单：它检查合约存储器索引为 2 处是否已使用，注意到它未被使用，然后将其值置为 CHARLIE。假设这消耗了 187 单位的燃料，于是剩余的燃料为 1150 – 187 = 963。</li>
<li>向发送者的账户增加 963*0.001=0.963 个以太币，返回最终状态。</li>
</ol>
<p>如果没有合约接收交易，那么所有的交易费用就等于 GASPRICE 乘以交易的字节长度，交易的数据就与交易费用无关了。<br>另外，需要注意的是，合约发起的消息可以对它们产生的计算分配燃料限额，如果子计算的燃料用完了，它只恢复到消息发出时的状态。因此，就像交易一样，合约也可以通过对它产生的子计算设置严格的限制，保护它们的计算资源。</p>
<p>从以上的过程上看，我们可以看出：<br>执行交易一共需要以下的gas：<br><strong>1. 执行交易预订gas费用</strong><br><strong>2. 随交易发送的数据的gas费用（按照字节）</strong><br><strong>3. 如果交易是合约创建交易，还需要额外的gas费用</strong></p>
<h2 id="代码执行（EVM层）"><a href="#代码执行（EVM层）" class="headerlink" title="代码执行（EVM层）"></a>代码执行（EVM层）</h2><p>以太坊合约的代码使用低级的基于堆栈的字节码的语言写成的，被称为“以太坊虚拟机代码”或者“EVM 代码”。代码由一系列字节构成，每一个字节代表一种操作。一般而言，代码执行是无限循环，程序计数器每增加一（初始值为零）就执行一次操作，直到代码执行完毕或者遇到错误， STOP 或者 RETURN 指令。<br><strong>像之前定义的那样，EVM是图灵完备虚拟机器。EVM本质上是被gas束缚-&gt;因此，可以完成的计算总量本质上是被提供的gas总量限制的。</strong><br>操作可以访问三种存储数据的空间：</p>
<ul>
<li>堆栈，一种后进先出的数据存储， 32 字节的数值可以入栈，出栈。</li>
<li>内存，可无限扩展的字节队列。</li>
<li>合约的长期存储，一个秘钥/数值的存储，其中秘钥和数值都是 32 字节大小，与计算结束即重置的堆栈和内存不同，存储内容将长期保持。代码可以象访问区块头数据一样访问数值，发送者和接受到的消息中的数据，代码还可以返回数据的字节队列作为输出。</li>
</ul>
<p><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180923111958189-2132863486.png" alt="img"></p>
<p>EVM 代码的正式执行模型令人惊讶地简单。当以太坊虚拟机运行时，它的完整的计算状态可以由元组(block_state, transaction, message, code, memory,stack, pc, gas)来定义，这里 block_state 是包含所有账户余额和存储的全局状态。每轮执行时，通过调出代码的第 pc（程序计数器）个字节，当前指令被找到，每个指令都有定义自己如何影响元组。例如， <strong>ADD 将两个元素出栈并将它们的和入栈，将 gas（燃料）减一并将 pc 加一， SSTORE 将顶部的两个元素出栈并将第二个元素插入到由第一个元素定义的合约存储位置，同样减少最多 200 的gas 值并将 pc 加一，</strong>虽然有许多方法通过即时编译去优化以太坊，但以太坊的基础性的实施可以用几百行代码实现。</p>
<h2 id="区块链和挖矿"><a href="#区块链和挖矿" class="headerlink" title="区块链和挖矿"></a>区块链和挖矿</h2><p>虽然有一些不同，但以太坊的区块链在很多方面类似于比特币区块链。<strong>它们的区块链架构的不同在于，以太坊区块不仅包含交易记录和最近的状态，还包含区块序号和难度值。</strong><br>以太坊中的区块确认算法如下：</p>
<ol>
<li>检查区块引用的上一个区块是否存在和有效</li>
<li>检查区块的时间戳是否比引用的上一个区块大，而且小于 15 分钟。</li>
<li>检查区块序号、难度值、 交易根，叔根和燃料限额是否有效。</li>
<li>检查区块的工作量证明是否有效。</li>
<li>将 S[0]赋值为上一个区块的 STATE_ROOT。</li>
<li>将 TX 赋值为区块的交易列表，一共有 n 笔交易。对于属于 0……n-1 的 i，进行状态转换 S[i+1] = APPLY(S[i],TX[i])。如果任何一个转换发生错误，或者程序执行到此处所花费的燃料（ gas）超过了 GASLIMIT，返回错误。</li>
<li>用 S[n]给 S_FINAL 赋值, 向矿工支付区块奖励。</li>
<li>检查 S-FINAL 是否与 STATE_ROOT 相同。如果相同，区块是有效的。否则，区块是无效的。</li>
</ol>
<p>这一确认方法乍看起来似乎效率很低，因为它需要存储每个区块的所有状态，但是事实上以太坊的确认效率可以与比特币相提并论。原因是状态存储在树结构中，每增加一个区块只需要改变树结构的一小部分。因此，一般而言，两个相邻的区块的树结构的大部分应该是相同的，因此存储一次数据，可以利用指针（即子树哈希）引用两次。一种被称为<a href="https://www.cnblogs.com/fengzhiwu/p/5584809.html" target="_blank" rel="noopener">帕特里夏树（ ”Patricia Tree”）</a>的树结构可以实现这一点，其中包括了对默克尔树概念的修改，不仅允许改变节点，而且还可以插入和删除节点。另外，因为所有的状态信息是最后一个区块的一部分，所以没有必要存储全部的区块历史-这一方法如果能够可以应用到比特币系统中，经计算可以对存储空间有 10-20 倍的节省。</p>
<h1 id="以太坊应用举例"><a href="#以太坊应用举例" class="headerlink" title="以太坊应用举例"></a>以太坊应用举例</h1><p>以太坊应用一般分为三类：</p>
<ol>
<li>金融应用，为用户提供更强大的用他们的钱管理和参与合约的方法。包括子货币，金融衍生品，对冲合约，储蓄钱包，遗嘱，甚至一些种类的全面的雇佣合约。</li>
<li>半金融应用，这里有钱的存在但也有很重的非金钱的方面，一个完美的例子是为解决计算问题而设的自我强制悬赏。</li>
<li>还有在线投票和去中心化治理这样的完全的非金融应用。</li>
</ol>
<h2 id="令牌系统"><a href="#令牌系统" class="headerlink" title="令牌系统"></a>令牌系统</h2><p>链上令牌系统有很多应用，从代表如美元或黄金等资产的子货币到公司股票，单独的令牌代表智能资产，安全的不可伪造的优惠券，甚至与传统价值完全没有联系的用来进行积分奖励的令牌系统。在以太坊中实施令牌系统容易得让人吃惊。<br>关键的一点是理解，所有的货币或者令牌系统，从根本上来说是一个带有如下操作的数据库：从 A 中减去 X 单位并把 X 单位加到 B 上，前提条件是(1)A 在交易之前有至少 X 单位以及(2)交易被 A 批准。实施一个令牌系统就是把这样一个逻辑实施到一个合约中去。用 Serpent 语言实施一个令牌系统的基本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from = msg.sender</span><br><span class="line">to = msg.data[0]</span><br><span class="line">value = msg.data[1]</span><br><span class="line">if contract.storage[from] &gt;= value:</span><br><span class="line">contract.storage[from] = contract.storage[from] -value</span><br><span class="line">contract.storage[to] = contract.storage[to] + value</span><br></pre></td></tr></table></figure>

<p>这从本质上来说是本文将要进一步描述的“银行系统”状态转变功能的一个最小化实施。需要增加一些额外的代码以提供在初始和其它一些边缘情况下分发货币的功能，理想情况下会增加一个函数让其它合约来查询一个地址的余额。就足够了。</p>
<p>理论上，基于以太坊的充当子货币的令牌系统可能包括一个基于比特币的链上元币所缺乏的重要功能：直接用这种货币支付交易费的能力。实现这种能力的方法是在合约里维护一个以太币账户以用来为发送者支付交易费，通过收集被用来充当交易费用的内部货币并把它们在一个不断运行的拍卖中拍卖掉，合约不断为该以太币账户注资。这样用户需要用以太币“激活”他们的账户，但一旦账户中有以太币它将会被重复使用因为每次合约都会为其充值。(??..what)</p>
<h2 id="金融衍生品和价值稳定的货币"><a href="#金融衍生品和价值稳定的货币" class="headerlink" title="金融衍生品和价值稳定的货币"></a>金融衍生品和价值稳定的货币</h2><h3 id="对冲合约"><a href="#对冲合约" class="headerlink" title="对冲合约"></a>对冲合约</h3><p>金融衍生品是“智能合约”的最普遍的应用，也是最易于用代码实现的之一。实现金融合约的主要挑战是它们中的大部分需要参照一个外部的价格发布器；例如，一个需求非常大的应用是一个用来对冲以太币（或其它密码学货币）相对美元价格波动的智能合约，但该合约需要知道以太币相对美元的价格。最简单的方法是通过由某特定机构（例如纳斯达克）维护的“数据提供“合约进行，该合约的设计使得该机构能够根据需要更新合约，并提供一个接口使得其它合约能够通过发送一个消息给该合约以获取包含价格信息的回复.</p>
<p>当这些关键要素都齐备，对冲合约看起来会是下面的样子：<br>等待 A 输入 1000 以太币。 .<br>等待 B 输入 1000 以太币。<br>通过查询数据提供合约，将 1000 以太币的美元价值，例如， x 美元，记录至存储器。</p>
<p>30 天后，允许 A 或 B“重新激活“合约以发送价值 x 美元的以太币（重新查询数据提供合约，以获取新价格并计算）给 A 并将剩余的以太币发送给 B。<br>这样的合约在密码学商务中有非同寻常的潜力。密码学货币经常被诟病的一个问题就是其价格的波动性；虽然大量的用户和商家可能需要密码学资产所带来的安全和便利，可他们不太会乐意面对一天中资产跌去 23%价值的情形。（某特定机构例如纳斯达克应该是会维护价格的稳定性）</p>
<h3 id="发行者背书资产与去中心化市场"><a href="#发行者背书资产与去中心化市场" class="headerlink" title="发行者背书资产与去中心化市场"></a>发行者背书资产与去中心化市场</h3><p>直到现在，最为常见的推荐方案是发行者背书资产；思想是发行者创建一种子货币，对此种子货币他们有权发行和赎回，给予（线下）提供给他们一个单位特定相关资产（例如黄金，美元）的人一个单位子货币。发行者承诺当任何人送还一个单位密码学资产时。发还一个单位的相关资产。这种机制能够使任何非密码学资产被“升级“为密码学资产，如果发行者值得信任的话.</p>
<p>然而实践中发行者并非总是值得信任的，并且一些情况下银行体系太脆弱，或者不够诚实守信从而使这样的服务无法存在。金融衍生品提供了一种替代方案。这里将不再有提供储备以支撑一种资产的单独的发行者，取而代之的是一个由赌一种密码学资产的价格会上升的投机者构成的去中心化市场。与发行者不同，投机者一方没有讨价还价的权利，因为对冲合约把他们的储备冻结在了契约中。注意这种方法并非是完全去中心化的，因为依然需要一个可信任的提供价格信息的数据源，尽管依然有争议这依然是在降低基础设施需求（与发行者不同，一个价格发布器不需要牌照并且似乎可归为自由言论一类）和降低潜在欺诈风险方面的一个巨大的进步。</p>
<h2 id="身份和信誉系统"><a href="#身份和信誉系统" class="headerlink" title="身份和信誉系统"></a>身份和信誉系统</h2><p>最早的替代币，域名币，尝试使用一个类比特币块链来提供一个名称注册系统，在那里用户可以将他们的名称和其它数据一起在一个公共数据库注册。最常用的应用案例把象“bitcoin.org“（或者再域名币中， ”bitcoin.bit“）一样的域名与一个IP 地址对应的域名系统。其它的应用案例包括电子邮件验证系统和潜在的更先进的信誉系统。这里是以太坊中提供与域名币类似的的名称注册系统的基础合约.</p>
<blockquote>
<p>if !contract.storage[tx.data[0]]:<br>contract.storage[tx.data[0]] = tx.data[1]</p>
</blockquote>
<p>合约非常简单；就是一个以太坊网络中的可以被添加但不能被修改或移除的数据库。任何人都可以把一个名称注册为一个值并永远不变。一个更复杂的名称注册合约将包含允许其他合约查询的“功能条款“，以及一个让一个名称的”拥有者（即 “第一个注册者）修改数据或者转让所有权的机制。甚至可以在其上添加信誉和信任网络功能。</p>
<h2 id="去中心化存储"><a href="#去中心化存储" class="headerlink" title="去中心化存储"></a>去中心化存储</h2><p>在过去的几年里出现了一些大众化的在线文件存储初创公司，最突出的是Dropbox，它寻求允许用户上传他们的硬盘备份， 提供备份存储服务并允许用户访问从而按月向用户收取费用。然而，在这一点上这个文件存储市场有时相对低效；对现存服务的粗略观察表明，特别地在“神秘谷“20-200GB 这一既没有免费空间也没有企业级用户折扣的水平上，主流文件存储成本每月的价格意味着支付在一个月里支付整个硬盘的成本。以太坊合约允许去中心化存储生态的开发，这样用户通过将他们自己的硬盘或未用的网络空间租出去以获得少量收益，从而降低了文件存储的成本。</p>
<p>这样的设施的基础性构件就是我们所谓的“去中心化 Dropbox 合约“。这个合约工作原理如下。</p>
<ol>
<li>某人将需要上传的数据分成块，对每一块数据加密以保护隐私，并且以此构建一个默克尔树。然后创建一个含以下规则的合约，每 N 个块，合约将从默克尔树中抽取一个随机索引</li>
<li>给第一个实体 X 以太以支撑在树中特定索引处的块的所有权证明。当一个用户想重新下载他的文件，他可以使用微支付通道协议（例如每 32k 字节支付 1 萨博）恢复文件。</li>
</ol>
<p>这个协议的一个重要特征是，虽然看起来象是一个人信任许多不准备丢失文件的随机节点，但是他可以通过秘密分享把文件分成许多小块，然后通过监视合同得知每个小块都还被某个节点的保存着。如果一个合约依然在付款，那么就提供了某个人依然在保存文件的证据。</p>
<h2 id="去中心化自治组织（-DAO）"><a href="#去中心化自治组织（-DAO）" class="headerlink" title="去中心化自治组织（ DAO）"></a>去中心化自治组织（ DAO）</h2><p>通常意义上“去中心化自治组织（ DAO）”的概念指的是一个拥有一定数量成员或股东的虚拟实体，依靠比如 67%多数来决定花钱以及修改代码。成员会集体决定组织如何分配资金。分配资金的方法可能是悬赏，工资或者更有吸引力的机制比如用内部货币奖励工作。这仅仅使用密码学块链技术就从根本上复制了传统公司或者非营利组织的法律意义以实现强制执行。至此许多围绕 DAO 的讨论都是围绕一个带有接受分红的股东和可交易的股份的“去中心化自治公司（ DAC） ”的“资本家”模式；作为替代者，一个被描述为“去中心化自治社区”的实体将使所有成员都在决策上拥有同等的权利并且在增减成员时要求 67%多数同意。每个人都只能拥有一个成员资格这一规则需要被群体强制实施。</p>
<p>下面是一个如何用代码实现 DO 的纲要。最简单的设计就是一段如果三分之二成员同意就可以自我修改的代码。虽然理论上代码是不可更改的，然而通过把代码主干放在一个单独的合约内并且把合约调用的地址指向一个可更改的存储依然可以容易地绕开障碍而使代码变得可修改，在一个这样的 DAO 合约的简单实现中有三种交易类型，由交易提供的数据区分：</p>
<ul>
<li>[0,i,K,V] 注册索引为 i 的对存储地址索引为 K 至 v 的内容的更改建议。</li>
<li>[0,i] 注册对建议 i 的投票。</li>
<li>[2,i] 如有足够投票则确认建议 i。</li>
</ul>
<p>然后合约对每一项都有具体的条款。它将维护一个所有开放存储的更改记录以及一个谁投票表决的表。还有一个所有成员的表。当任何存储内容的更改获得了三分之二多数同意，一个最终的交易将执行这项更改。一个更加复杂的框架会增加内置的选举功能以实现如发送交易，增减成员，甚至提供委任制民主一类的投票代表（即任何人都可以委托另外一个人来代表自己投票，而且这种委托关系是可以传递的，所以如果 A 委托了 B 然后 B 委托了 C 那么 C 将决定 A 的投票）。这种设计将使 DAO 作为一个去中心化社区有机地成长， 使人们最终能够把挑选合适人选的任务交给专家， 与当前系统不同，随着社区成员不断改变他们的站队假以时日专家会容易地出现和消失。</p>
<p>一个替代的模式是去中心化公司，那里任何账户可以拥有 0 到更多的股份，决策需要三分之二多数的股份同意。一个完整的框架将包括资产管理功能-可以提交买卖股份的订单以及接受这种订单的功能（前提是合约里有订单匹配机制）。代表依然以委任制民主的方式存在，产生了“董事会”的概念。</p>
<p>更先进的组织治理机制可能会在将来实现；现在一个去中心化组织（ DO）可以从去中心化自治组织（ DAO）开始描述。 DO 和 DAO 的区别是模糊的，一个大致的分割线是治理是否可以通过一个类似政治的过程或者一个“自动”过程实现，一个不错的直觉测试是“无通用语言”标准：如果两个成员不说同样的语言组织还能正常运行吗？显然，一个简单的传统的持股式公司会失败，而像比特币协议这样的却很可能成功，罗宾· 汉森的“futarchy”，一个通过预测市场实现组织化治理的机制是一个真正的说明“自治”式治理可能是什么样子的好例子。注意一个人无需假设所有 DAO 比所有 DO 优越；自治只是一个在一些特定场景下有很大优势的，但在其它地方未必可行的范式，许多半 DAO 可能存在。</p>
<h3 id="进一步应用"><a href="#进一步应用" class="headerlink" title="进一步应用"></a>进一步应用</h3><ul>
<li>储蓄钱包</li>
<li>作物保险</li>
<li>去中心化的数据发布器</li>
<li>多重签名智能契约</li>
<li>云计算</li>
<li>点对点赌博</li>
<li>预测市场</li>
<li>链上去中心化市场</li>
</ul>
<h1 id="相关杂项"><a href="#相关杂项" class="headerlink" title="相关杂项"></a>相关杂项</h1><h2 id="改进版幽灵协议的实施"><a href="#改进版幽灵协议的实施" class="headerlink" title="改进版幽灵协议的实施"></a>改进版幽灵协议的实施</h2><p>两个问题</p>
<ol>
<li><p>幽灵协议提出的动机是当前快速确认的块链因为区块的高作废率而受到低安全性困扰</p>
<blockquote>
<p>区块需要花一定时间（设为 t）扩散至全网，如果矿工 A 挖出了一个区块然后矿工 B 碰巧在 A 的区块扩散至 B 之前挖出了另外一个区块，矿工 B 的区块就会作废并且没有对网络安全作出贡献。<br>解决：通过在计算哪条链“最长”的时候把废区块也包含进来，幽灵协议解决了降低网络安全性的第一个问题；这就是说，不仅一个区块的父区块和更早的祖先块，祖先块的作废的后代区块也被加进来以计算哪一个区块拥有支持其的最大工作量证明。</p>
</blockquote>
</li>
<li><p>算力中心化问题</p>
<blockquote>
<p>如果 A 是一个拥有全网 30%算力的矿池而 B 拥有 10%的算力， A 将面临 70%的时间都在产生作废区块的风险而 B 在 90%的时间里都在产生作废区块。因此，如果作废率高，A 将简单地因为更高的算力份额而更有效率。<br>解决：以太坊实施了一个只下探到有限层的简化版本的幽灵协议。其特点是，废区块只能以叔区块的身份被其父母的第二代至第五代后辈区块，而不是更远关系的后辈区块（例如父母区块的第六代后辈区块，或祖父区块的第三代后辈区块）纳入计算。这样做有几个原因。1. 无条件的幽灵协议将给计算给定区块的哪一个叔区块合法带来过多的复杂性。2. 带有以太坊所使用的无条件补偿的幽灵协议剥夺了矿工的一部分激励。</p>
</blockquote>
</li>
</ol>
<p>最后，计算表明带有激励的五层幽灵协议即使在出块时间为 15s 的情况下也实现了了 95%以上的效率，而拥有 25%算力的矿工从中心化得到的益处小于 3%。</p>
<h2 id="费用"><a href="#费用" class="headerlink" title="费用"></a>费用</h2><p>因为每个发布到区块链的交易都占用了下载和验证的成本，需要有一个包括交易费的规范机制来防范滥发交易。<br>比特币使用的默认方法是纯自愿的交易费用，依靠矿工担当守门人并设定动态的最低费用。因为这种方法是“基于市场的”，使得矿工和交易发送者能够按供需来决定价格，所以这种方法在比特币社区被很顺利地接受了。然而，这个逻辑的问题在于，交易处理并非一个市场；虽然根据直觉把交易处理解释成矿工给发送者提供的服务是很有吸引力的，但事实上一个矿工收录的交易是需要网络中每个节点处理的，所以交易处理中最大部分的成本是由第三方而不是决定是否收录交易的矿工承担的。</p>
<p>然而，当给出一个特殊的不够精确的简化假设时，这个基于市场的机制的漏洞很神奇地消除了自己的影响。论证如下。假设：</p>
<blockquote>
</blockquote>
<ol>
<li>一个交易带来 k 步操作, 提供奖励 kR 给任何收录该交易的矿工，这里 R 由交易发布者设定， k 和 R 对于矿工都是事先（大致上）可见的。</li>
<li>每个节点处理每步操作的成本都是 C (即所有节点的效率一致)。</li>
<li>有 N 个挖矿节点，每个算力一致(即全网算力的 1/N)。</li>
<li>没有不挖矿的全节点</li>
</ol>
<p>当预期奖励大于成本时，矿工愿意挖矿。这样，因为矿工有 1/N 的机会处理下一个区块，所以预期的收益是 kR/N , 矿工的处理成本简单为 kC. 这样当kR/N &gt; kC， <strong>即 R &gt; NC 时。矿工愿意收录交易</strong>。注意 R 是由交易发送者提供的每步费用，是矿工从处理交易中获益的下限。 NC 是全网处理一个操作的成本。所以，矿工仅有动机去收录那些收益大于成本的交易。</p>
<p>然而，这些假设与实际情况有几点重要的偏离：</p>
<blockquote>
</blockquote>
<ol>
<li>因为额外的验证时间延迟了块的广播因而增加了块成为废块的机会，处理交易的矿工比其它的验证节点付出了更高的成本。</li>
<li>不挖矿的全节点是存在的。</li>
<li>实践中算力分布可能最后是极端不平均的。</li>
<li>以破坏网络为己任的投机者，政敌和疯子确实存在，并且他们能够聪明地设置合同使得他们的成本比其它验证节点低得多</li>
</ol>
<p>上面第 1 点驱使矿工收录更少的交易，第 2 点增加了 NC; 因此这两点的影响至少部分互相抵消了. <strong>第 3 点和第 4 点是主要问题；作为解决方案我们简单地建立了一个浮动的上限</strong>：没有区块能够比 BLK_LIMIT_FACTOR 倍长期指数移动平均值更多的操作数。具体地：</p>
<blockquote>
<p>blk.oplimit = floor((blk.parent.oplimit * (EMAFACTOR – 1) + floor(parent.opcount * BLK_LIMIT_FACTOR)) /EMA_FACTOR)</p>
</blockquote>
<p>BLK_LIMIT_FACTOR 和 EMA_FACTOR 是暂且被设为 65536 和 1.5 的常数，但可能会在更深入的分析后调整。</p>
<h2 id="计算和图灵完备"><a href="#计算和图灵完备" class="headerlink" title="计算和图灵完备"></a>计算和图灵完备</h2><p>需要强调的是以太坊虚拟机是图灵完备的； 这意味着 EVM 代码可以实现任何可以想象的计算，包括无限循环。 EVM 代码有两种方式实现循环。首先， JUMP指令可以让程序跳回至代码前面某处，还有允许如 while x &lt; 27: x = x * 2 一样的条件语句的 JUMPI 指令实现条件跳转。其次，合约可以调用其它合约，有通过递归实现循环的潜力。这很自然地导致了一个问题：恶意用户能够通过迫使矿工和全节点进入无限循环而不得不关机吗？ 这问题出现是因为计算机科学中一个叫停机问题(可计算理论)的问题：一般意义上没有办法知道，一个给定的程序是否能在有限的时间内结束运行。</p>
<p>正如在状态转换章节所述，我们的方案通过为每一个交易设定运行执行的最大计算步数来解决问题，如果超过则计算被恢复原状但依然要支付费用。消息以同样的方式工作。为显示这一方案背后的动机，请考虑下面的例子：</p>
<ul>
<li>一个攻击者创建了一个运行无限循环的合约，然后发送了一个激活循环的交易给矿工，矿工将处理交易，运行无限循环直到燃料耗尽。即使燃料耗尽交易半途停止，交易依然正确（回到原处）并且矿工依然从攻击者哪里挣到了每一步计算的费用。</li>
<li>一个攻击者创建一个非常长的无限循环意图迫使矿工长时间内一直计算致使在计算结束前若干区块已经产生于是矿工无法收录交易以赚取费用。然而，攻击者需要发布一个 STARTGAS 值以限制可执行步数，因而矿工将提前知道计算将耗费过多的步数。</li>
<li>一个攻击者看到一个包含诸如 send(A,contract.storage[A]); contract.storage[A]= 0 格式的合约然后发送带有只够执行第一步的费用的而不够执行第二步的交易（即提现但不减少账户余额）。合约作者无需担心防卫类似攻击，因为如果执行中途停止则所有变更都被回复。</li>
</ul>
<h3 id="选择图灵完备"><a href="#选择图灵完备" class="headerlink" title="选择图灵完备"></a>选择图灵完备</h3><p>图灵完备的替代品是图灵不完备，<strong>这里 JUMP 和 JUMPI 指令不存在并且在某个给定时间每个合约只允许有一个拷贝存在于调用堆栈内</strong>。在这样的系统里，上述的费用系统和围绕我们的方案的效率的不确定性可能都是不需要的，因为执行一个合约的成本将被它的大小决定。此外，图灵不完备甚至不是一个大的限制，在我们内部设想的所有合约例子中，至今只有一个需要循环，而且即使这循环也可以被 26 个单行代码段的重复所代替。考虑到图灵完备带来的严重的麻烦和有限的益处，为什么不简单地使用一种图灵不完备语言呢？事实上图灵不完备远非一个简洁的解决方案。为什么？请考虑下面的合约：</p>
<blockquote>
<p>C0: call(C1); call(C1);<br>C1: call(C2); call(C2);<br>C2: call(C3); call(C3);<br>…<br>C49: call(C50); call(C50);<br>C50: (run one step of a program and record the change in storage)</p>
</blockquote>
<p>现在，发送一个这样的交易给 A，这样，在 51 个交易中，我们有了一个需要花费 250 步计算的合约，<br>问题点：</p>
<ol>
<li>矿工可能尝试通过为每一个合约维护一个最高可执行步数并且对于递归调用其它合约的合约计算可能执行步数从而预先检测这样的逻辑炸弹，但是这<strong>会使矿工禁止创建其它合约的合约</strong>（因为上面 26 个合约的创建和执行可以很容易地放入一个单独合约内）。</li>
<li>另外一个问题点是一个消息的地址字段是一个变量，所以通常来讲可能甚至<strong>无法预先知道一个合约将要调用的另外一个合约是哪一个</strong>。<br>于是，最终我们有了一个惊人的结论：图灵完备的管理惊人地容易，而在缺乏同样的控制时图灵不完备的管理惊人地困难- 那为什么不让协议图灵完备呢？</li>
</ol>
<h2 id="货币和发行"><a href="#货币和发行" class="headerlink" title="货币和发行"></a>货币和发行</h2><p>以太坊网络包含自身的内置货币以太币，以太币扮演双重角色，为各种数字资产交易提供主要的流动性，更重要的是提供了了支付交易费用的一种机制。为便利及避免将来的争议期间（参见当前的 mBTC/uBTC/聪的争论），不同面值的名称将被提前设置:</p>
<ul>
<li>wei伟</li>
<li>10^12: 萨博</li>
<li>10^15: 芬尼</li>
<li>10^18: 以太</li>
</ul>
<p>这应该被当作是“元”和“分”或者“比特币”和“聪”的概念的扩展版，在不远的将来，我们期望“以太”被用作普通交易， “芬尼”用来进行微交易， “萨博”和“伟”用来进行关于费用和协议实施的讨论。</p>
<p>发行模式如下：</p>
<ul>
<li>通过发售活动，以太币将以每 BTC 1337-2000 以太的价格发售，一个旨在为以太坊组织筹资并且为开发者支付报酬的机制已经在其它一些密码学货币平台上成功使用。早期购买者会享受较大的折扣，发售所得的 BTC 将完全用来支付开发者和研究者的工资和悬赏，以及投入密码学货币生态系统的项目。</li>
<li>0.099x （ x 为发售总量）将被分配给 BTC 融资或其它的确定性融资成功之前参与开发的早期贡献者，另外一个 0.099x 将分配给长期研究项目。</li>
<li>自上线时起每年都将有 0.26x（ x 为发售总量）被矿工挖出。</li>
</ul>
<h2 id="发行分解"><a href="#发行分解" class="headerlink" title="发行分解"></a>发行分解</h2><p>永久线性增长模型降低了在比特币中出现的财富过于集中的风险，并且给予了活在当下和将来的人公平的机会去获取货币，同时保持了对获取和持有以太币的激励，因为长期来看“货币供应增长率”是趋于零的。我们还推断，随着时间流逝总会发生因为粗心和死亡等原因带来的币的遗失，假设币的遗失是每年货币供应量的一个固定比例，则最终总的流通中的货币供应量会稳定在一个等于年货币发行量除以遗失率的值上（例如，当遗失率为 1%时，当供应量达到 30x 时，每年有0.3x 被挖出同时有 0.3x 丢失， 达到一个均衡）。</p>
<p>除了线性的发行方式外，和比特币一样以太币的的供应量增长率长期来看也趋于零。</p>
<h2 id="挖矿的中心化"><a href="#挖矿的中心化" class="headerlink" title="挖矿的中心化"></a>挖矿的中心化</h2><p>比特币挖矿算法基本上是让矿工千万次地轻微改动区块头，直到最终某个节点的改动版本的哈希小于目标值。然而，这种挖矿算法容易被两种形式的中心化攻击。</p>
<ol>
<li>挖矿生态系统被专门设计的因而在比特币挖矿这一特殊任务上效率提高上千倍的 ASICs（专用集成电路）和电脑芯片控制。这意味着比特币挖矿不再是高度去中心化的和追求平等主义的，而是需要巨额资本的有效参与。</li>
<li>大部分比特币矿工事实上不再在本地完成区块验证；而是依赖中心化的矿池提供区块头。这个问题可以说很严重：有时最大的两个矿池间接地控制了大约全网 50%的算力，这就有联合体可能会尝试 51%攻击的可能性。</li>
</ol>
<p>以太坊使用以下两种方案:</p>
<ol>
<li>以太坊现在的目的是使用一个基于为每 1000 个随机数随机产生唯一哈希的函数的挖矿算法，<strong>用足够宽的计算域，去除专用硬件的优势</strong>。这样的策略当然不会使中心化的收益减少为零，但是也不需要。注意每单个用户使用他们的私人笔记本电脑或台式机就可以几乎免费地完成一定量的挖矿活动，<strong>但当到了 100%的 CPU使用率之后更多地挖矿就会需要他们支付电力和硬件成本</strong>。 ASIC 挖矿公司需要从第一个哈希开始就为电力和硬件支付成本。所以，如果中心化收益能够保持在(E + H) /E 以下，那么即使 ASICs 被制造出来普通矿工依然有生存空间。</li>
<li>计划将挖矿算法设计成挖矿需要访问整个区块链，<strong>迫使矿工存储完成的区块链或者至少能够验证每笔交易</strong>。这去除了对中心化矿池的需要；虽然矿池依然可以扮演平滑收益分配的随机性的角色，但这功能可以被没有中心化控制的 P2P矿池完成地同样好。这样即使大部分普通用户依然倾向选择轻客户端，<strong>通过增加网络中的全节点数量也有助于抵御中心化</strong>。</li>
</ol>
<h2 id="扩展性"><a href="#扩展性" class="headerlink" title="扩展性"></a>扩展性</h2><p>扩展性问题是以太坊常被关注的地方，与比特币一样，以太坊也遭受着每个交易都需要网络中的每个节点处理这一困境的折磨。比特币的当前区块链大小约为20GB，以每小时 1MB 的速度增长。以太坊可能也会经历相似的甚至更糟的增长模式，因为在以太坊区块链之上还有很多应用，而不是像比特币只是简单的货币，但以太坊全节点只需存储状态而不是完整的区块链历史这一事实让情况得到了改善。</p>
<p>大区块链的问题是中心化风险。如果块链大小增加至比如 100TB，可能的场景将是只有非常小数目的大商家会运行全节点，而常规用户使用轻的 SPV 节点。这会增加对全节点合伙欺诈牟利（例如更改区块奖励，给他们自己 BTC）的风险的担忧。轻节点将没有办法立刻检测到这种欺诈。当然，至少可能存在一个诚实的全节点，并且几个小时之后有关诈骗的信息会通过 Reddit 这样的渠道泄露，但这时已经太晚：任凭普通用户做出怎样的努力去废除已经产生的区块，他们都会遇到与发动一次成功的 51%攻击同等规模的巨大的不可行的协调问题。在比特币这里，现在这是一个问题，但 Peter Todd 建议的一个改动可以缓解这个问题。</p>
<p>以太坊会使用两个附加的策略以应对此问题。</p>
<ol>
<li>因为基于区块链的挖矿算法，至少每个矿工会被迫成为一个全节点，这保证了一定数量的全节点。</li>
<li>更重要的是，处理完每笔交易后，我们会把一个中间状态树的根包含进区块链。即使区块验证是中心化的，只要有一个诚实的验证节点存在，中心化的问题就可以通过一个验证协议避免。如果一个矿工发布了一个不正确的区块，这区块要么是格式错，要么状态 S[n]是错的。因为 S[0]是正确的，必然有第一个错误状态 S[i]但 S[i-1]是正确的，验证节点将提供索引 i，一起提供的还有处理APPLY(S[i-1],TX[i]) -&gt; S[i]所需的帕特里夏树节点的子集。这些节点将受命进行这部分计算，看产生的 S[i]与先前提供的值是否一致。</li>
</ol>
<p>更复杂的是恶意矿工发布不完整区块进行攻击，造成没有足够的信息去确定区块是否正确。解决方案是质疑-回应协议：验证节点对目标交易索引发起质疑，接受到质疑信息的轻节点会对相应的区块取消信任，直到另外一个矿工或者验证者提供一个帕特里夏节点子集作为正确的证据。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><strong>上述合约机制使得任何一个人能够在一个虚拟机上建立通过全网共识来运行命令行应用，它能够更改一个全网可访问的状态作为它的“硬盘”。</strong><br>以太坊的比较完整的架构如下：<br><img src="https://img2018.cnblogs.com/blog/1460364/201809/1460364-20180929083845669-95838683.jpg" alt="img"></p>
<p>然而，对于多数人来说，用作交易发送机制的命令行接口缺乏足够的用户友好使得去中心化成为有吸引力的替代方案。一个完整的“去中心化应用”应该包括底层的商业逻辑组件和上层的图形用户接口组件。以太坊客户端被设计成一个网络浏览器，但包括对“eth” Javascript API 对象的支持，可被客户端里看到的特定的网页用来与以太坊区块链交互。从“传统”网页的角度看来，这些网页是完全静态的内容，因为区块链和其它去中心化协议将完全代替服务器来处理用户发起的请求。最后，去中心化协议有希望自己利用某种方式使用以太坊来存储网页。</p>
<p>以太坊协议最初是作为一个通过高度通用的语言提供如链上契约，提现限制和金融合约，赌博市场等高级功能的升级版密码学货币来构思的。以太坊协议将不直接“支持”任何应用，但图灵完备编程语言的存在意味着理论上任意的合约都可以为任何交易类型和应用创建出来。然而关于以太坊更有趣的是，以太坊协议比单纯的货币走得更远，围绕去中心化存储，去中心化计算和去中心化预测市场以及数十个类似概念建立的协议和去中心化应用，有潜力从根本上提升计算行业的效率。最终，同样会有大批与金钱毫无关系的应用出现。</p>
<p>以太坊协议实现的任意状态转换概念提供了一个具有独特潜力的平台；与封闭式的，为诸如数据存储，赌博或金融等单一目的设计的协议不同，以太坊从设计上是开放式的，并且我们相信它极其适合作为基础层服务于在将来的年份里出现的极其大量的金融和非金融协议。</p>
<p>最后，附上<a href="https://github.com/ethereum/go-ethereum" target="_blank" rel="noopener">以太坊</a>的官方github链接</p>

</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2018/08/14/myarticle58/">prev</a>
    

    
    <p>last update time 2019-09-05</p>
    
    
        <a class="extend next post-next" href="/2018/07/12/myarticle56/">next</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:1178752402@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/CaiChenghan" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://www.jianshu.com/u/565c8e790605" title="jianshu" target="_self">
					<i class="fa fa-jianshu"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © 小飞 2017 - 2019
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a href="https://hexo.io">Hexo</a> & <a href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
