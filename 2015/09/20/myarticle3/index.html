<!DOCTYPE html>

<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  
  <title>python七大查找算法 [ Pandsflies ]</title>
  
    <!-- stylesheets list from config.yml -->
    
      <link rel="stylesheet" href="/css/iLiKE.css">
    
  
  
  
  <script src="//cdn1.lncld.net/static/js/3.1.1/av-min.js"></script>
    <script id="leancloud">
      AV.init({
          appId: "6E5zTbTljdUbVW2WkXPsXGJk-gzGzoHsz",
          appKey: "0vsyDKfNpeSECAI70J794ugv"
      });
    </script>

</head></html>
<body>
    <div class="header">
        <div class="container">
    <div class="menu">
      <div class="menu-left">
        <a href="/">
          <img src="/favicon.ico"></img>
        </a>
      </div>
      <div class="menu-right">
        
          
          
          
          
          
          
          <a href="/">Home</a>
        
          
          
          
          
          
          
          <a href="/archives">Archives</a>
        
          
          
          
          
          
          <a href="/about">Resume</a>
        
          
          
          
          
          
          <a href="/E-BOOK">E-book</a>
        
      </div>
    </div>
</div>
    </div>
    <div class="container">
        <h1 class="post-title">python七大查找算法</h1>
<article class="post markdown-style">
  <h2 id="查找算法"><a href="#查找算法" class="headerlink" title="查找算法"></a>查找算法</h2><h4 id="查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。-查找表（Search-Table）：由同一类型的数据元素构成的集合-关键字（Key）：数据元素中某个数据项的值，又称为键值-主键（Primary-Key）：可唯一的标识某个数据元素或记录的关键字"><a href="#查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。-查找表（Search-Table）：由同一类型的数据元素构成的集合-关键字（Key）：数据元素中某个数据项的值，又称为键值-主键（Primary-Key）：可唯一的标识某个数据元素或记录的关键字" class="headerlink" title="查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。     查找表（Search Table）：由同一类型的数据元素构成的集合     关键字（Key）：数据元素中某个数据项的值，又称为键值     主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字"></a>查找（Searching）就是根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。     查找表（Search Table）：由同一类型的数据元素构成的集合     关键字（Key）：数据元素中某个数据项的值，又称为键值     主键（Primary Key）：可唯一的标识某个数据元素或记录的关键字</h4><h5 id="查找表按照操作方式可分为："><a href="#查找表按照操作方式可分为：" class="headerlink" title="查找表按照操作方式可分为："></a><strong>查找表按照操作方式可分为：</strong></h5><h4 id="1-静态查找表（Static-Search-Table）：只做查找操作的查找表。它的主要操作是："><a href="#1-静态查找表（Static-Search-Table）：只做查找操作的查找表。它的主要操作是：" class="headerlink" title="1.静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是："></a>1.静态查找表（Static Search Table）：只做查找操作的查找表。它的主要操作是：</h4><h4 id="①查询某个“特定的”数据元素是否在表中-②检索某个“特定的”数据元素和各种属性"><a href="#①查询某个“特定的”数据元素是否在表中-②检索某个“特定的”数据元素和各种属性" class="headerlink" title="①查询某个“特定的”数据元素是否在表中         ②检索某个“特定的”数据元素和各种属性"></a>①查询某个“特定的”数据元素是否在表中         ②检索某个“特定的”数据元素和各种属性</h4><h4 id="2-动态查找表（Dynamic-Search-Table）：在查找中同时进行插入或删除等操作："><a href="#2-动态查找表（Dynamic-Search-Table）：在查找中同时进行插入或删除等操作：" class="headerlink" title="2.动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作："></a>2.动态查找表（Dynamic Search Table）：在查找中同时进行插入或删除等操作：</h4><h4 id="①查找时插入数据-②查找时删除数据"><a href="#①查找时插入数据-②查找时删除数据" class="headerlink" title="①查找时插入数据         ②查找时删除数据"></a>①查找时插入数据         ②查找时删除数据</h4><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><h4 id="算法简介"><a href="#算法简介" class="headerlink" title="算法简介"></a>算法简介</h4><p>​       顺序查找又称为线性查找，是一种最简单的查找方法。适用于线性表的顺序存储结构和链式存储结构。该算法的时间复杂度为O(n)。</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>​       <strong>从第一个元素m开始逐个与需要查找的元素x进行比较，当比较到元素值相同(即m=x)时返回元素m的下标，如果比较到最后都没有找到，则返回-1。</strong></p>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>​    <strong>缺点：是当n 很大时，平均查找长度较大，效率低；</strong><br>    优点：是对表中数据元素的存储没有要求。另外，对于线性链表，只能进行顺序查找。</p>
<h4 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 最基础的遍历无序列表的查找算法</span><br><span class="line"># 时间复杂度O(n)</span><br><span class="line"> </span><br><span class="line">def sequential_search(lis, key):</span><br><span class="line">  length = len(lis)</span><br><span class="line">  for i in range(length):</span><br><span class="line">    if lis[i] == key:</span><br><span class="line">      return i</span><br><span class="line">    else:</span><br><span class="line">      return False</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  LIST = [1, 5, 8, 123, 22, 54, 7, 99, 300, 222]</span><br><span class="line">  result = sequential_search(LIST, 123)</span><br><span class="line">  print(result)</span><br></pre></td></tr></table></figure>

<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>算法简介</p>
<h5 id="二分查找（Binary-Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。-这种查找算法每一次比较都使查找范围缩小一半。"><a href="#二分查找（Binary-Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。-这种查找算法每一次比较都使查找范围缩小一半。" class="headerlink" title="二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。    这种查找算法每一次比较都使查找范围缩小一半。"></a><strong>二分查找（Binary Search），是一种在有序数组中查找某一特定元素的查找算法。查找过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则查找过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。</strong>    <strong>这种查找算法每一次比较都使查找范围缩小一半。</strong></h5><h4 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h4><p>​    <strong>给予一个包含</strong> n<strong>个带值元素的数组A</strong> </p>
<h5 id="1、-令-L为0-，-R为-n-1-；-2、-如果L-gt-R，则搜索以失败告终-；-3、-令-m-中间值元素-为-⌊-L-R-2⌋；-4、-如果-Am-lt-T，令-L为-m-1-并回到步骤二-；-5、-如果-Am-gt-T，令-R为-m-1-并回到步骤二；"><a href="#1、-令-L为0-，-R为-n-1-；-2、-如果L-gt-R，则搜索以失败告终-；-3、-令-m-中间值元素-为-⌊-L-R-2⌋；-4、-如果-Am-lt-T，令-L为-m-1-并回到步骤二-；-5、-如果-Am-gt-T，令-R为-m-1-并回到步骤二；" class="headerlink" title="1、 令 L为0 ， R为 n-1 ；        2、 如果L&gt;R，则搜索以失败告终 ；        3、 令 m (中间值元素)为  ⌊(L+R)/2⌋；         4、 如果 Am&lt;T，令 L为 m + 1 并回到步骤二 ；        5、 如果 Am&gt;T，令 R为 m - 1 并回到步骤二；"></a><strong>1、 令 L为0 ， R为 n-1 ；</strong>        <strong>2、 如果L&gt;R，则搜索以失败告终 ；</strong>        3、 令 m (中间值元素)为  ⌊(L+R)/2⌋；         <strong>4、 如果 Am&lt;T，令 L为 m + 1 并回到步骤二 ；</strong>        <strong>5、 如果 Am&gt;T，令 R为 m - 1 并回到步骤二；</strong></h5><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​    时间复杂度：折半搜索每次把搜索区域减少一半，时间复杂度为 O(logn)<br>    空间复杂度：<strong>O(1)</strong></p>
<h4 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 针对有序查找表的二分查找算法</span><br><span class="line"> </span><br><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = 0</span><br><span class="line">  high = len(lis) - 1</span><br><span class="line">  time = 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time += 1</span><br><span class="line">    mid = int((low + high) / 2)</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high = mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low = mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印折半的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]</span><br><span class="line">  result = binary_search(LIST, 99)</span><br><span class="line">  print(result)</span><br></pre></td></tr></table></figure>

<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>算法简介</p>
<h5 id="插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的-查找方法，其核心就在于插值的计算公式-key-a-low-a-high-a-low-high-low-。-时间复杂度o-logn-但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。"><a href="#插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的-查找方法，其核心就在于插值的计算公式-key-a-low-a-high-a-low-high-low-。-时间复杂度o-logn-但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。" class="headerlink" title="插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。    时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。"></a><strong>插值查找是根据要查找的关键字key与查找表中最大最小记录的关键字比较后的 查找方法，其核心就在于插值的计算公式 (key-a[low])/(a[high]-a[low])*(high-low)。</strong>    <strong>时间复杂度o(logn)但对于表长较大而关键字分布比较均匀的查找表来说，效率较高。</strong></h5><h4 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h4><h5 id="基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。-注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。"><a href="#基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。-注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。" class="headerlink" title="基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。     注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。"></a>基于二分查找算法，将查找点的选择改进为自适应选择，可以提高查找效率。当然，差值查找也属于有序查找。     注：对于表长较大，而关键字分布又比较均匀的查找表来说，插值查找算法的平均性能比折半查找要好的多。反之，数组中如果分布非常不均匀，那么插值查找未必是很合适的选择。</h5><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​    <strong>时间复杂性：如果元素均匀分布，则O（log log n）），在最坏的情况下可能需要 O（n）。    空间复杂度：O（1）。</strong></p>
<h4 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 插值查找算法</span><br><span class="line"> </span><br><span class="line">def binary_search(lis, key):</span><br><span class="line">  low = 0</span><br><span class="line">  high = len(lis) - 1</span><br><span class="line">  time = 0</span><br><span class="line">  while low &lt; high:</span><br><span class="line">    time += 1</span><br><span class="line">    # 计算mid值是插值算法的核心代码</span><br><span class="line">    mid = low + int((high - low) * (key - lis[low])/(lis[high] - lis[low]))</span><br><span class="line">    print(&quot;mid=%s, low=%s, high=%s&quot; % (mid, low, high))</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high = mid - 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low = mid + 1</span><br><span class="line">    else:</span><br><span class="line">      # 打印查找的次数</span><br><span class="line">      print(&quot;times: %s&quot; % time)</span><br><span class="line">      return mid</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]</span><br><span class="line">  result = binary_search(LIST, 444)</span><br><span class="line">  print(result)</span><br></pre></td></tr></table></figure>

<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p>算法简介</p>
<p>​    <strong>斐波那契数列，又称黄金分割数列，指的是这样一个数列：1、1、2、3、5、8、13、21、····，在数学上，斐波那契被递归方法如下定义：F(1)=1，F(2)=1，F(n)=f(n-1)+F(n-2) （n&gt;=2）。该数列越往后相邻的两个数的比值越趋向于黄金比例值（0.618）。</strong></p>
<h4 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h4><p>​    <strong>斐波那契查找就是在二分查找的基础上根据斐波那契数列进行分割的。在斐波那契数列找一个等于略大于查找表中元素个数的数F[n]，将原查找表扩展为长度为F<a href="如果要补充元素，则补充重复最后一个元素，直到满足F[n]个元素">n</a>，完成后进行斐波那契分割，即F[n]个元素分割为前半部分F[n-1]个元素，后半部分F[n-2]个元素，找出要查找的元素在那一部分并递归，直到找到。</strong></p>
<h4 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​    <strong>最坏情况下，时间复杂度为O(log2n)，且其期望复杂度也为O(log2n)。</strong></p>
<h4 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"># 斐波那契查找算法</span><br><span class="line"># 时间复杂度O(log(n))</span><br><span class="line"> </span><br><span class="line">def fibonacci_search(lis, key):</span><br><span class="line">  # 需要一个现成的斐波那契列表。其最大元素的值必须超过查找表中元素个数的数值。</span><br><span class="line">  F = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144,</span><br><span class="line">     233, 377, 610, 987, 1597, 2584, 4181, 6765,</span><br><span class="line">     10946, 17711, 28657, 46368]</span><br><span class="line">  low = 0</span><br><span class="line">  high = len(lis) - 1</span><br><span class="line">   </span><br><span class="line">  # 为了使得查找表满足斐波那契特性，在表的最后添加几个同样的值</span><br><span class="line">  # 这个值是原查找表的最后那个元素的值</span><br><span class="line">  # 添加的个数由F[k]-1-high决定</span><br><span class="line">  k = 0</span><br><span class="line">  while high &gt; F[k]-1:</span><br><span class="line">    k += 1</span><br><span class="line">  print(k)</span><br><span class="line">  i = high</span><br><span class="line">  while F[k]-1 &gt; i:</span><br><span class="line">    lis.append(lis[high])</span><br><span class="line">    i += 1</span><br><span class="line">  print(lis)</span><br><span class="line">   </span><br><span class="line">  # 算法主逻辑。time用于展示循环的次数。</span><br><span class="line">  time = 0</span><br><span class="line">  while low &lt;= high:</span><br><span class="line">    time += 1</span><br><span class="line">    # 为了防止F列表下标溢出，设置if和else</span><br><span class="line">    if k &lt; 2:</span><br><span class="line">      mid = low</span><br><span class="line">    else:</span><br><span class="line">      mid = low + F[k-1]-1</span><br><span class="line">     </span><br><span class="line">    print(&quot;low=%s, mid=%s, high=%s&quot; % (low, mid, high))</span><br><span class="line">    if key &lt; lis[mid]:</span><br><span class="line">      high = mid - 1</span><br><span class="line">      k -= 1</span><br><span class="line">    elif key &gt; lis[mid]:</span><br><span class="line">      low = mid + 1</span><br><span class="line">      k -= 2</span><br><span class="line">    else:</span><br><span class="line">      if mid &lt;= high:</span><br><span class="line">        # 打印查找的次数</span><br><span class="line">        print(&quot;times: %s&quot; % time)</span><br><span class="line">        return mid</span><br><span class="line">      else:</span><br><span class="line">        print(&quot;times: %s&quot; % time)</span><br><span class="line">        return high</span><br><span class="line">  print(&quot;times: %s&quot; % time)</span><br><span class="line">  return False</span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  LIST = [1, 5, 7, 8, 22, 54, 99, 123, 200, 222, 444]</span><br><span class="line">  result = fibonacci_search(LIST, 444)</span><br><span class="line">  print(result)</span><br></pre></td></tr></table></figure>

<h2 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h2><h4 id="1、二叉树查找算法。"><a href="#1、二叉树查找算法。" class="headerlink" title="1、二叉树查找算法。"></a>1、二叉树查找算法。</h4><p>​        算法简介</p>
<p>​    <strong>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</strong> </p>
<h4 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h4><h5 id="二叉查找树（BinarySearch-Tree）或者是一棵空树，或者是具有下列性质的二叉树：-1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；-2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；-3）任意节点的左、右子树也分别为二叉查找树。"><a href="#二叉查找树（BinarySearch-Tree）或者是一棵空树，或者是具有下列性质的二叉树：-1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；-2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；-3）任意节点的左、右子树也分别为二叉查找树。" class="headerlink" title="　　二叉查找树（BinarySearch Tree）或者是一棵空树，或者是具有下列性质的二叉树： 　　    1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 　　    2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 　　    3）任意节点的左、右子树也分别为二叉查找树。"></a>　　二叉查找树（BinarySearch Tree）或者是一棵空树，或者是具有下列性质的二叉树： 　　    1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 　　    2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 　　    3）任意节点的左、右子树也分别为二叉查找树。</h5><h5 id="二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。"><a href="#二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。" class="headerlink" title="　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。"></a>　　二叉查找树性质：对二叉查找树进行中序遍历，即可得到有序的数列。</h5><p><img src="https://img-blog.csdn.net/2018071011092880?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​     <strong>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。</strong></p>
<h4 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"># 二叉树查找 Python实现</span><br><span class="line">class BSTNode:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    定义一个二叉树节点类。</span><br><span class="line">    以讨论算法为主，忽略了一些诸如对数据类型进行判断的问题。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self, data, left=None, right=None):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化</span><br><span class="line">        :param data: 节点储存的数据</span><br><span class="line">        :param left: 节点左子树</span><br><span class="line">        :param right: 节点右子树</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        self.data = data</span><br><span class="line">        self.left = left</span><br><span class="line">        self.right = right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BinarySortTree:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    基于BSTNode类的二叉查找树。维护一个根节点的指针。</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self._root = None</span><br><span class="line"></span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self._root is None</span><br><span class="line"></span><br><span class="line">    def search(self, key):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        关键码检索</span><br><span class="line">        :param key: 关键码</span><br><span class="line">        :return: 查询节点或None</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        bt = self._root</span><br><span class="line">        while bt:</span><br><span class="line">            entry = bt.data</span><br><span class="line">            if key &lt; entry:</span><br><span class="line">                bt = bt.left</span><br><span class="line">            elif key &gt; entry:</span><br><span class="line">                bt = bt.right</span><br><span class="line">            else:</span><br><span class="line">                return entry</span><br><span class="line">        return None</span><br><span class="line"></span><br><span class="line">    def insert(self, key):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        插入操作</span><br><span class="line">        :param key:关键码 </span><br><span class="line">        :return: 布尔值</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        bt = self._root</span><br><span class="line">        if not bt:</span><br><span class="line">            self._root = BSTNode(key)</span><br><span class="line">            return</span><br><span class="line">        while True:</span><br><span class="line">            entry = bt.data</span><br><span class="line">            if key &lt; entry:</span><br><span class="line">                if bt.left is None:</span><br><span class="line">                    bt.left = BSTNode(key)</span><br><span class="line">                    return</span><br><span class="line">                bt = bt.left</span><br><span class="line">            elif key &gt; entry:</span><br><span class="line">                if bt.right is None:</span><br><span class="line">                    bt.right = BSTNode(key)</span><br><span class="line">                    return</span><br><span class="line">                bt = bt.right</span><br><span class="line">            else:</span><br><span class="line">                bt.data = key</span><br><span class="line">                return</span><br><span class="line"></span><br><span class="line">    def delete(self, key):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        二叉查找树最复杂的方法</span><br><span class="line">        :param key: 关键码</span><br><span class="line">        :return: 布尔值</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        p, q = None, self._root     # 维持p为q的父节点，用于后面的链接操作</span><br><span class="line">        if not q:</span><br><span class="line">            print(&quot;空树！&quot;)</span><br><span class="line">            return</span><br><span class="line">        while q and q.data != key:</span><br><span class="line">            p = q</span><br><span class="line">            if key &lt; q.data:</span><br><span class="line">                q = q.left</span><br><span class="line">            else:</span><br><span class="line">                q = q.right</span><br><span class="line">            if not q:               # 当树中没有关键码key时，结束退出。</span><br><span class="line">                return</span><br><span class="line">        # 上面已将找到了要删除的节点，用q引用。而p则是q的父节点或者None（q为根节点时）。</span><br><span class="line">        if not q.left:</span><br><span class="line">            if p is None:</span><br><span class="line">                self._root = q.right</span><br><span class="line">            elif q is p.left:</span><br><span class="line">                p.left = q.right</span><br><span class="line">            else:</span><br><span class="line">                p.right = q.right</span><br><span class="line">            return</span><br><span class="line">        # 查找节点q的左子树的最右节点，将q的右子树链接为该节点的右子树</span><br><span class="line">        # 该方法可能会增大树的深度，效率并不算高。可以设计其它的方法。</span><br><span class="line">        r = q.left</span><br><span class="line">        while r.right:</span><br><span class="line">            r = r.right</span><br><span class="line">        r.right = q.right</span><br><span class="line">        if p is None:</span><br><span class="line">            self._root = q.left</span><br><span class="line">        elif p.left is q:</span><br><span class="line">            p.left = q.left</span><br><span class="line">        else:</span><br><span class="line">            p.right = q.left</span><br><span class="line"></span><br><span class="line">    def __iter__(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        实现二叉树的中序遍历算法,</span><br><span class="line">        展示我们创建的二叉查找树.</span><br><span class="line">        直接使用python内置的列表作为一个栈。</span><br><span class="line">        :return: data</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        stack = []</span><br><span class="line">        node = self._root</span><br><span class="line">        while node or stack:</span><br><span class="line">            while node:</span><br><span class="line">                stack.append(node)</span><br><span class="line">                node = node.left</span><br><span class="line">            node = stack.pop()</span><br><span class="line">            yield node.data</span><br><span class="line">            node = node.right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    lis = [62, 58, 88, 48, 73, 99, 35, 51, 93, 29, 37, 49, 56, 36, 50]</span><br><span class="line">    bs_tree = BinarySortTree()</span><br><span class="line">    for i in range(len(lis)):</span><br><span class="line">        bs_tree.insert(lis[i])</span><br><span class="line">    # bs_tree.insert(100)</span><br><span class="line">    bs_tree.delete(58)</span><br><span class="line">    for i in bs_tree:</span><br><span class="line">        print(i, end=&quot; &quot;)</span><br><span class="line">    # print(&quot;\n&quot;, bs_tree.search(4))</span><br></pre></td></tr></table></figure>

<p><strong>2、平衡查找树之2-3查找树（2-3 Tree）</strong></p>
<h4 id="2-3查找树定义"><a href="#2-3查找树定义" class="headerlink" title="2-3查找树定义"></a>2-3查找树定义</h4><p>   <strong>和二叉树不一样，2-3树运行每个节点保存1个或者两个的值。对于普通的2节点(2-node)，他保存1个key和左右两个自己点。对应3节点(3-node)，保存两个Key，2-3查找树的定义如下： 　　 1）要么为空，要么： 　　 2）对于2节点，该节点保存一个key及对应value，以及两个指向左右节点的节点，左节点也是一个2-3节点，所有的值都比key要小，右节点也是一个2-3节点，所有的值比key要大。 　　 3）对于3节点，该节点保存两个key及对应value，以及三个指向左中右的节点。左节点也是一个2-3节点，所有的值均比两个key中的最小的key还要小；中间节点也是一个2-3节点，中间节点的key值在两个跟节点key值之间；右节点也是一个2-3节点，节点的所有key值比两个key中的最大的key还要大。</strong></p>
<h4 id="2-3查找树的性质"><a href="#2-3查找树的性质" class="headerlink" title="2-3查找树的性质"></a>2-3查找树的性质</h4><p>　　 <strong>1）如果中序遍历2-3查找树，就可以得到排好序的序列； 　　 2）在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。（这也是平衡树中“平衡”一词的概念，根节点到叶节点的最长距离对应于查找算法的最坏情况，而平衡树中根节点到叶节点的距离都一样，最坏情况也具有对数复杂度。）</strong> </p>
<h4 id="2-3树的查找效率与树的高度是息息相关的。"><a href="#2-3树的查找效率与树的高度是息息相关的。" class="headerlink" title="　 2-3树的查找效率与树的高度是息息相关的。"></a>　 <strong>2-3树的查找效率与树的高度是息息相关的。</strong></h4><p>​    <strong>距离来说，对于1百万个节点的2-3树，树的高度为12-20之间，对于10亿个节点的2-3树，树的高度为18-30之间。</strong> 　　<strong>对于插入来说，只需要常数次操作即可完成，因为他只需要修改与该节点关联的节点即可，不需要检查其他节点，所以效率和查找类似。</strong></p>
<p><img src="https://img-blog.csdn.net/20180709232049358?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="算法实现-5"><a href="#算法实现-5" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">class Node(object):</span><br><span class="line">    def __init__(self,key):</span><br><span class="line">        self.key1=key</span><br><span class="line">        self.key2=None</span><br><span class="line">        self.left=None</span><br><span class="line">        self.middle=None</span><br><span class="line">        self.right=None</span><br><span class="line">    def isLeaf(self):</span><br><span class="line">        return self.left is None and self.middle is None and self.right is None</span><br><span class="line">    def isFull(self):</span><br><span class="line">        return self.key2 is not None</span><br><span class="line">    def hasKey(self,key):</span><br><span class="line">        if (self.key1==key) or (self.key2 is not None and self.key2==key):</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    def getChild(self,key):</span><br><span class="line">        if key&lt;self.key1:</span><br><span class="line">            return self.left</span><br><span class="line">        elif self.key2 is None:</span><br><span class="line">            return self.middle</span><br><span class="line">        elif key&lt;self.key2:</span><br><span class="line">            return self.middle</span><br><span class="line">        else:</span><br><span class="line">            return self.right</span><br><span class="line">class 2_3_Tree(object):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.root=None</span><br><span class="line">    def get(self,key):</span><br><span class="line">        if self.root is None:</span><br><span class="line">            return None</span><br><span class="line">        else:</span><br><span class="line">            return self._get(self.root,key)</span><br><span class="line">    def _get(self,node,key):</span><br><span class="line">        if node is None:</span><br><span class="line">            return None</span><br><span class="line">        elif node.hasKey(key):</span><br><span class="line">            return node</span><br><span class="line">        else:</span><br><span class="line">            child=node.getChild(key)</span><br><span class="line">            return self._get(child,key)</span><br><span class="line">    def put(self,key):</span><br><span class="line">        if self.root is None:</span><br><span class="line">            self.root=Node(key)</span><br><span class="line">        else:</span><br><span class="line">            pKey,pRef=self._put(self.root,key)</span><br><span class="line">            if pKey is not None:</span><br><span class="line">                newnode=Node(pKey)</span><br><span class="line">                newnode.left=self.root</span><br><span class="line">                newnode.middle=pRef</span><br><span class="line">                self.root=newnode</span><br><span class="line">    def _put(self,node,key):</span><br><span class="line">        if node.hasKey(key):</span><br><span class="line">            return None,None</span><br><span class="line">        elif node.isLeaf():</span><br><span class="line">            return self._addtoNode(node,key,None)</span><br><span class="line">        else:</span><br><span class="line">            child=node.getChild(key)</span><br><span class="line">            pKey,pRef=self._put(child,key)</span><br><span class="line">            if pKey is None:</span><br><span class="line">                return None,None</span><br><span class="line">            else:</span><br><span class="line">                return self._addtoNode(node,pKey,pRef)</span><br><span class="line">             </span><br><span class="line">         </span><br><span class="line">    def _addtoNode(self,node,key,pRef):</span><br><span class="line">        if node.isFull():</span><br><span class="line">            return self._splitNode(node,key,pRef)</span><br><span class="line">        else:</span><br><span class="line">            if key&lt;node.key1:</span><br><span class="line">                node.key2=node.key1</span><br><span class="line">                node.key1=key</span><br><span class="line">                if pRef is not None:</span><br><span class="line">                    node.right=node.middle</span><br><span class="line">                    node.middle=pRef</span><br><span class="line">            else:</span><br><span class="line">                node.key2=key</span><br><span class="line">                if pRef is not None:</span><br><span class="line">                    node.right=Pref</span><br><span class="line">            return None,None</span><br><span class="line">    def _splitNode(self,node,key,pRef):</span><br><span class="line">        newnode=Node(None)</span><br><span class="line">        if key&lt;node.key1:</span><br><span class="line">            pKey=node.key1</span><br><span class="line">            node.key1=key</span><br><span class="line">            newnode.key1=node.key2</span><br><span class="line">            if pRef is not None:</span><br><span class="line">                newnode.left=node.middle</span><br><span class="line">                newnode.middle=node.right</span><br><span class="line">                node.middle=pRef</span><br><span class="line">        elif key&lt;node.key2:</span><br><span class="line">            pKey=key</span><br><span class="line">            newnode.key1=node.key2</span><br><span class="line">            if pRef is not None:</span><br><span class="line">                newnode.left=Pref</span><br><span class="line">                newnode.middle=node.right</span><br><span class="line">        else:</span><br><span class="line">            pKey=node.key2</span><br><span class="line">            newnode.key1=key</span><br><span class="line">            if pRef is not None:</span><br><span class="line">                newnode.left=node.right</span><br><span class="line">                newnode.middle=pRef</span><br><span class="line">        node.key2=None</span><br><span class="line">        return pKey,newnode</span><br></pre></td></tr></table></figure>

<h4 id="3、平衡查找树之红黑树（Red-Black-Tree）"><a href="#3、平衡查找树之红黑树（Red-Black-Tree）" class="headerlink" title="3、平衡查找树之红黑树（Red-Black Tree）"></a>3、平衡查找树之红黑树（Red-Black Tree）</h4><h4 id="红黑树的定义"><a href="#红黑树的定义" class="headerlink" title="红黑树的定义"></a>红黑树的定义</h4><p>　　 <strong>红黑树是一种具有红色和黑色链接的平衡查找树，同时满足：</strong><br>　　   <strong>① 红色节点向左倾斜 ；</strong><br>　　   <strong>②一个节点不可能有两个红色链接；</strong><br>       <strong>③整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同。</strong></p>
<h4 id="红黑树的性质"><a href="#红黑树的性质" class="headerlink" title="红黑树的性质"></a>红黑树的性质</h4><p>​     <strong>整个树完全黑色平衡，即从根节点到所以叶子结点的路径上，黑色链接的个数都相同（2-3树的第2）性质，从根节点到叶子节点的距离都相等）。</strong></p>
<p><img src="https://img-blog.csdn.net/20180709232532947?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="复杂度分析-4"><a href="#复杂度分析-4" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​    <strong>最坏的情况就是，红黑树中除了最左侧路径全部是由3-node节点组成，即红黑相间的路径长度是全黑路径长度的2倍。 　　下图是一个典型的红黑树，从中可以看到最长的路径(红黑相间的路径)是最短路径的2倍：</strong></p>
<p><img src="https://img-blog.csdn.net/20180709232622985?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="算法实现-6"><a href="#算法实现-6" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br></pre></td><td class="code"><pre><span class="line">#红黑树</span><br><span class="line">from random import randint</span><br><span class="line"></span><br><span class="line">RED = &apos;red&apos;</span><br><span class="line">BLACK = &apos;black&apos;</span><br><span class="line"></span><br><span class="line">class RBT:</span><br><span class="line">    def __init__(self):</span><br><span class="line">       # self.items = []</span><br><span class="line">        self.root = None</span><br><span class="line">        self.zlist = []</span><br><span class="line"></span><br><span class="line">    def LEFT_ROTATE(self, x):</span><br><span class="line">        # x是一个RBTnode</span><br><span class="line">        y = x.right</span><br><span class="line">        if y is None:</span><br><span class="line">            # 右节点为空，不旋转</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            beta = y.left</span><br><span class="line">            x.right = beta</span><br><span class="line">            if beta is not None:</span><br><span class="line">                beta.parent = x</span><br><span class="line"></span><br><span class="line">            p = x.parent</span><br><span class="line">            y.parent = p</span><br><span class="line">            if p is None:</span><br><span class="line">                # x原来是root</span><br><span class="line">                self.root = y</span><br><span class="line">            elif x == p.left:</span><br><span class="line">                p.left = y</span><br><span class="line">            else:</span><br><span class="line">                p.right = y</span><br><span class="line">            y.left = x</span><br><span class="line">            x.parent = y</span><br><span class="line"></span><br><span class="line">    def RIGHT_ROTATE(self, y):</span><br><span class="line">        # y是一个节点</span><br><span class="line">        x = y.left</span><br><span class="line">        if x is None:</span><br><span class="line">            # 右节点为空，不旋转</span><br><span class="line">            return</span><br><span class="line">        else:</span><br><span class="line">            beta = x.right</span><br><span class="line">            y.left = beta</span><br><span class="line">            if beta is not None:</span><br><span class="line">                beta.parent = y</span><br><span class="line"></span><br><span class="line">            p = y.parent</span><br><span class="line">            x.parent = p</span><br><span class="line">            if p is None:</span><br><span class="line">                # y原来是root</span><br><span class="line">                self.root = x</span><br><span class="line">            elif y == p.left:</span><br><span class="line">                p.left = x</span><br><span class="line">            else:</span><br><span class="line">                p.right = x</span><br><span class="line">            x.right = y</span><br><span class="line">            y.parent = x</span><br><span class="line"></span><br><span class="line">    def INSERT(self, val):</span><br><span class="line"></span><br><span class="line">        z = RBTnode(val)</span><br><span class="line">        y = None</span><br><span class="line">        x = self.root</span><br><span class="line">        while x is not None:</span><br><span class="line">            y = x</span><br><span class="line">            if z.val &lt; x.val:</span><br><span class="line">                x = x.left</span><br><span class="line">            else:</span><br><span class="line">                x = x.right</span><br><span class="line"></span><br><span class="line">        z.PAINT(RED)</span><br><span class="line">        z.parent = y</span><br><span class="line"></span><br><span class="line">        if y is None:</span><br><span class="line">            # 插入z之前为空的RBT</span><br><span class="line">            self.root = z</span><br><span class="line">            self.INSERT_FIXUP(z)</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        if z.val &lt; y.val:</span><br><span class="line">            y.left = z</span><br><span class="line">        else:</span><br><span class="line">            y.right = z</span><br><span class="line"></span><br><span class="line">        if y.color == RED:</span><br><span class="line">            # z的父节点y为红色，需要fixup。</span><br><span class="line">            # 如果z的父节点y为黑色，则不用调整</span><br><span class="line">            self.INSERT_FIXUP(z)</span><br><span class="line"></span><br><span class="line">        else:</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">    def INSERT_FIXUP(self, z):</span><br><span class="line">        # case 1:z为root节点</span><br><span class="line">        if z.parent is None:</span><br><span class="line">            z.PAINT(BLACK)</span><br><span class="line">            self.root = z</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # case 2:z的父节点为黑色</span><br><span class="line">        if z.parent.color == BLACK:</span><br><span class="line">            # 包括了z处于第二层的情况</span><br><span class="line">            # 这里感觉不必要啊。。似乎z.parent为黑色则不会进入fixup阶段</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # 下面的几种情况，都是z.parent.color == RED:</span><br><span class="line">        # 节点y为z的uncle</span><br><span class="line">        p = z.parent</span><br><span class="line">        g = p.parent  # g为x的grandpa</span><br><span class="line">        if g is None:</span><br><span class="line">            return</span><br><span class="line">            #   return 这里不能return的。。。</span><br><span class="line">        if g.right == p:</span><br><span class="line">            y = g.left</span><br><span class="line">        else:</span><br><span class="line">            y = g.right</span><br><span class="line"></span><br><span class="line">        # case 3-0:z没有叔叔。即：y为NIL节点</span><br><span class="line">        # 注意，此时z的父节点一定是RED</span><br><span class="line">        if y == None:</span><br><span class="line">            if z == p.right and p == p.parent.left:</span><br><span class="line">                # 3-0-0:z为右儿子,且p为左儿子，则把p左旋</span><br><span class="line">                # 转化为3-0-1或3-0-2的情况</span><br><span class="line">                self.LEFT_ROTATE(p)</span><br><span class="line">                p, z = z, p</span><br><span class="line">                g = p.parent</span><br><span class="line">            elif z == p.left and p == p.parent.right:</span><br><span class="line">                self.RIGHT_ROTATE(p)</span><br><span class="line">                p, z = z, p</span><br><span class="line"></span><br><span class="line">            g.PAINT(RED)</span><br><span class="line">            p.PAINT(BLACK)</span><br><span class="line">            if p == g.left:</span><br><span class="line">                # 3-0-1:p为g的左儿子</span><br><span class="line">                self.RIGHT_ROTATE(g)</span><br><span class="line">            else:</span><br><span class="line">                # 3-0-2:p为g的右儿子</span><br><span class="line">                self.LEFT_ROTATE(g)</span><br><span class="line"></span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        # case 3-1:z有黑叔</span><br><span class="line">        elif y.color == BLACK:</span><br><span class="line">            if p.right == z and p.parent.left == p:</span><br><span class="line">                # 3-1-0:z为右儿子,且p为左儿子,则左旋p</span><br><span class="line">                # 转化为3-1-1或3-1-2</span><br><span class="line">                self.LEFT_ROTATE(p)</span><br><span class="line">                p, z = z, p</span><br><span class="line">            elif p.left == z and p.parent.right == p:</span><br><span class="line">                self.RIGHT_ROTATE(p)</span><br><span class="line">                p, z = z, p</span><br><span class="line"></span><br><span class="line">            p = z.parent</span><br><span class="line">            g = p.parent</span><br><span class="line"></span><br><span class="line">            p.PAINT(BLACK)</span><br><span class="line">            g.PAINT(RED)</span><br><span class="line">            if p == g.left:</span><br><span class="line">                # 3-1-1:p为g的左儿子，则右旋g</span><br><span class="line">                self.RIGHT_ROTATE(g)</span><br><span class="line">            else:</span><br><span class="line">                # 3-1-2:p为g的右儿子，则左旋g</span><br><span class="line">                self.LEFT_ROTATE(g)</span><br><span class="line"></span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        # case 3-2:z有红叔</span><br><span class="line">        # 则涂黑父和叔，涂红爷，g作为新的z，递归调用</span><br><span class="line">        else:</span><br><span class="line">            y.PAINT(BLACK)</span><br><span class="line">            p.PAINT(BLACK)</span><br><span class="line">            g.PAINT(RED)</span><br><span class="line">            new_z = g</span><br><span class="line">            self.INSERT_FIXUP(new_z)</span><br><span class="line"></span><br><span class="line">    def DELETE(self, val):</span><br><span class="line">        curNode = self.root</span><br><span class="line">        while curNode is not None:</span><br><span class="line">            if val &lt; curNode.val:</span><br><span class="line">                curNode = curNode.left</span><br><span class="line">            elif val &gt; curNode.val:</span><br><span class="line">                curNode = curNode.right</span><br><span class="line">            else:</span><br><span class="line">                # 找到了值为val的元素,正式开始删除</span><br><span class="line"></span><br><span class="line">                if curNode.left is None and curNode.right is None:</span><br><span class="line">                    # case1:curNode为叶子节点：直接删除即可</span><br><span class="line">                    if curNode == self.root:</span><br><span class="line">                        self.root = None</span><br><span class="line">                    else:</span><br><span class="line">                        p = curNode.parent</span><br><span class="line">                        if curNode == p.left:</span><br><span class="line">                            p.left = None</span><br><span class="line">                        else:</span><br><span class="line">                            p.right = None</span><br><span class="line"></span><br><span class="line">                elif curNode.left is not None and curNode.right is not None:</span><br><span class="line">                    sucNode = self.SUCCESOR(curNode)</span><br><span class="line">                    curNode.val, sucNode.val  = sucNode.val, curNode.val</span><br><span class="line">                    self.DELETE(sucNode.val)</span><br><span class="line"></span><br><span class="line">                else:</span><br><span class="line">                    p = curNode.parent</span><br><span class="line">                    if curNode.left is None:</span><br><span class="line">                        x = curNode.right</span><br><span class="line">                    else:</span><br><span class="line">                        x = curNode.left</span><br><span class="line">                    if curNode == p.left:</span><br><span class="line">                        p.left = x</span><br><span class="line">                    else:</span><br><span class="line">                        p.right = x</span><br><span class="line">                    x.parent = p</span><br><span class="line">                    if curNode.color == BLACK:</span><br><span class="line">                        self.DELETE_FIXUP(x)</span><br><span class="line"></span><br><span class="line">                curNode = None</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    def DELETE_FIXUP(self, x):</span><br><span class="line">        p = x.parent</span><br><span class="line">        # w:x的兄弟结点</span><br><span class="line">        if x == p.left:</span><br><span class="line">            w = x.right</span><br><span class="line">        else:</span><br><span class="line">            w = x.left</span><br><span class="line"></span><br><span class="line">        # case1:x的兄弟w是红色的</span><br><span class="line">        if w.color == RED:</span><br><span class="line">            p.PAINT(RED)</span><br><span class="line">            w.PAINT(BLACK)</span><br><span class="line">            if w == p.right:</span><br><span class="line">                self.LEFT_ROTATE(p)</span><br><span class="line">            else:</span><br><span class="line">                self.RIGHT_ROTATE(p)</span><br><span class="line"></span><br><span class="line">        if w.color == BLACK:</span><br><span class="line">            # case2:x的兄弟w是黑色的，而且w的两个孩子都是黑色的</span><br><span class="line">            if w.left.color == BLACK and w.right.color == BLACK:</span><br><span class="line">                w.PAINT(RED)</span><br><span class="line">                if p.color == BLACK:</span><br><span class="line">                    return</span><br><span class="line">                else:</span><br><span class="line">                    p.color = BLACK</span><br><span class="line">                    self.DELETE_FIXUP(p)</span><br><span class="line"></span><br><span class="line">            # case3:x的兄弟w是黑色的，而且w的左儿子是红色的，右儿子是黑色的</span><br><span class="line">            if w.left.color == RED and w.color == BLACK:</span><br><span class="line">                w.left.PAINT(BLACK)</span><br><span class="line">                w.PAINT(RED)</span><br><span class="line">                self.RIGHT_ROTATE(w)</span><br><span class="line"></span><br><span class="line">            # case4:x的兄弟w是黑色的，而且w的右儿子是红</span><br><span class="line">            if w.right.color == RED:</span><br><span class="line">                p.PAINT(BLACK)</span><br><span class="line">                w.PAINT(RED)</span><br><span class="line">                if w == p.right:</span><br><span class="line">                    self.LEFT_ROTATE(p)</span><br><span class="line">                else:</span><br><span class="line">                    self.RIGHT_ROTATE(p)</span><br><span class="line"></span><br><span class="line">    def SHOW(self):</span><br><span class="line">        self.DISPLAY1(self.root)</span><br><span class="line">        return self.zlist</span><br><span class="line"></span><br><span class="line">    def DISPLAY1(self, node):</span><br><span class="line">        if node is None:</span><br><span class="line">            return</span><br><span class="line">        self.DISPLAY1(node.left)</span><br><span class="line">        self.zlist.append(node.val)</span><br><span class="line">        self.DISPLAY1(node.right)</span><br><span class="line"></span><br><span class="line">    def DISPLAY2(self, node):</span><br><span class="line">        if node is None:</span><br><span class="line">            return</span><br><span class="line">        self.DISPLAY2(node.left)</span><br><span class="line">        print(node.val)</span><br><span class="line">        self.DISPLAY2(node.right)</span><br><span class="line"></span><br><span class="line">    def DISPLAY3(self, node):</span><br><span class="line">        if node is None:</span><br><span class="line">            return</span><br><span class="line">        self.DISPLAY3(node.left)</span><br><span class="line">        self.DISPLAY3(node.right)</span><br><span class="line">        print(node.val)</span><br><span class="line"></span><br><span class="line">class RBTnode:</span><br><span class="line">    &apos;&apos;&apos;红黑树的节点类型&apos;&apos;&apos;</span><br><span class="line">    def __init__(self, val):</span><br><span class="line">        self.val = val</span><br><span class="line">        self.left = None</span><br><span class="line">        self.right = None</span><br><span class="line">        self.parent = None</span><br><span class="line"></span><br><span class="line">    def PAINT(self, color):</span><br><span class="line">        self.color = color</span><br><span class="line"></span><br><span class="line">def zuoxuan(b, c):</span><br><span class="line">    a = b.parent</span><br><span class="line">    a.left = c</span><br><span class="line">    c.parent = a</span><br><span class="line">    b.parent = c</span><br><span class="line">    c.left = b</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    rbt=RBT()</span><br><span class="line">    b = []</span><br><span class="line"></span><br><span class="line">    for i in range(100):</span><br><span class="line">        m = randint(0, 500)</span><br><span class="line">        rbt.INSERT(m)</span><br><span class="line">        b.append(m)</span><br><span class="line"></span><br><span class="line">    a = rbt.SHOW()</span><br><span class="line">    b.sort()</span><br><span class="line">    equal = True</span><br><span class="line">    for i in range(100):</span><br><span class="line">        if a[i] != b[i]:</span><br><span class="line">            equal = False</span><br><span class="line">            break</span><br><span class="line"></span><br><span class="line">    if not equal:</span><br><span class="line">        print(&apos;wrong&apos;)</span><br><span class="line">    else:</span><br><span class="line">        print(&apos;OK!&apos;)</span><br></pre></td></tr></table></figure>

<h4 id="4、B树和B-树（B-Tree-B-Tree）"><a href="#4、B树和B-树（B-Tree-B-Tree）" class="headerlink" title="4、B树和B+树（B Tree/B+ Tree）"></a>4、B树和B+树（B Tree/B+ Tree）</h4><p>​     B树简介</p>
<p>​    <strong>B 树可以看作是对2-3查找树的一种扩展，即他允许每个节点有M-1个子节点。        ①根节点至少有两个子节点；        ②每个节点有M-1个key，并且以升序排列；        ③位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间；        ④非叶子结点的关键字个数=指向儿子的指针个数-1；        ⑤非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] ；        ⑥其它节点至少有M/2个子节点；        ⑦所有叶子结点位于同一层；     如：（M=3）</strong></p>
<p><img src="https://img-blog.csdn.net/20180710113715413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<h4 id="B树算法思想"><a href="#B树算法思想" class="headerlink" title="B树算法思想"></a>B树算法思想</h4><p>​    <strong>B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点；</strong></p>
<h4 id="B树的特性"><a href="#B树的特性" class="headerlink" title="B树的特性"></a>B树的特性</h4><p>​     <strong>1.关键字集合分布在整颗树中；     2.任何一个关键字出现且只出现在一个结点中；     3.搜索有可能在非叶子结点结束；     4.其搜索性能等价于在关键字全集内做一次二分查找；     5.自动层次控制；     由于限制了除根结点以外的非叶子结点，至少含有M/2个儿子，确保了结点的至少利用率，其最底搜索性能为O(LogN)</strong></p>
<p>​     B+ 树简介</p>
<p>​    B+树是B-树的变体，也是一种多路搜索树：<br>       1.其定义基本与B-树同，除了：<br>       2.非叶子结点的子树指针与关键字个数相同；<br>       3.非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树<br>       4.B-树是开区间；<br>       5.为所有叶子结点增加一个链指针；<br>       6.所有关键字都在叶子结点出现；</p>
<p>​    如：（M=3）</p>
<p><img src="https://img-blog.csdn.net/20180710112652679?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p>
<p>​     <strong>B+树算法思想</strong></p>
<p>​    <strong>B+的搜索与B-树也基本相同，区别是B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中），其性能也等价于在关键字全集做一次二分查找；</strong></p>
<h4 id="B-树的特性"><a href="#B-树的特性" class="headerlink" title="B+树的特性"></a>B+树的特性</h4><p>​      <strong>1.所有关键字都出现在叶子结点的链表中（稠密索引），且链表中的关键字恰好是有序的；      2.不可能在非叶子结点命中；      3.非叶子结点相当于是叶子结点的索引（稀疏索引），叶子结点相当于是存储（关键字）数据的数据层；      4.更适合文件索引系统；</strong></p>
<h4 id="算法实现-7"><a href="#算法实现-7" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line"># B树查找</span><br><span class="line"></span><br><span class="line">class BTree:  #B树</span><br><span class="line">    def __init__(self,value):</span><br><span class="line">        self.left=None</span><br><span class="line">        self.data=value</span><br><span class="line">        self.right=None</span><br><span class="line"></span><br><span class="line">    def insertLeft(self,value):</span><br><span class="line">        self.left=BTree(value)</span><br><span class="line">        return self.left</span><br><span class="line"></span><br><span class="line">    def insertRight(self,value):</span><br><span class="line">        self.right=BTree(value)</span><br><span class="line">        return self.right</span><br><span class="line"></span><br><span class="line">    def show(self):</span><br><span class="line">        print(self.data)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def inorder(node):  #中序遍历：先左子树，再根节点，再右子树</span><br><span class="line">    if node.data:</span><br><span class="line">        if node.left:</span><br><span class="line">            inorder(node.left)</span><br><span class="line">        node.show()</span><br><span class="line">        if node.right:</span><br><span class="line">            inorder(node.right)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def rinorder(node):  #倒中序遍历</span><br><span class="line">    if node.data:</span><br><span class="line">        if node.right:</span><br><span class="line">            rinorder(node.right)</span><br><span class="line">        node.show()</span><br><span class="line">        if node.left:</span><br><span class="line">            rinorder(node.left)</span><br><span class="line"></span><br><span class="line">def insert(node,value):</span><br><span class="line">    if value &gt; node.data:</span><br><span class="line">        if node.right:</span><br><span class="line">            insert(node.right,value)</span><br><span class="line">        else:</span><br><span class="line">            node.insertRight(value)</span><br><span class="line">    else:</span><br><span class="line">        if node.left:</span><br><span class="line">            insert(node.left,value)</span><br><span class="line">        else:</span><br><span class="line">            node.insertLeft(value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line"></span><br><span class="line">    l=[88,11,2,33,22,4,55,33,221,34]</span><br><span class="line">    Root=BTree(l[0])</span><br><span class="line">    node=Root</span><br><span class="line">    for i in range(1,len(l)):</span><br><span class="line">        insert(Root,l[i])</span><br><span class="line"></span><br><span class="line">    print(&quot;中序遍历（从小到大排序 ）&quot;)</span><br><span class="line">    inorder(Root)</span><br><span class="line">    print(&quot;倒中序遍历（从大到小排序）&quot;)</span><br><span class="line">    rinorder(Root)</span><br></pre></td></tr></table></figure>

<h4 id="5、树表查找总结"><a href="#5、树表查找总结" class="headerlink" title="5、树表查找总结"></a>5、树表查找总结</h4><p>　　<strong>二叉查找树平均查找性能不错，为O(logn)，但是最坏情况会退化为O(n)。在二叉查找树的基础上进行优化，我们可以使用平衡查找树。平衡查找树中的2-3查找树，这种数据结构在插入之后能够进行自平衡操作，从而保证了树的高度在一定的范围内进而能够保证最坏情况下的时间复杂度。但是2-3查找树实现起来比较困难，红黑树是2-3树的一种简单高效的实现，他巧妙地使用颜色标记来替代2-3树中比较难处理的3-node节点问题。红黑树是一种比较高效的平衡查找树，应用非常广泛，很多编程语言的内部实现都或多或少的采用了红黑树。 　　除此之外，2-3查找树的另一个扩展——B/B+平衡树，在文件系统和数据库系统中有着广泛的应用。</strong></p>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>算法简介</p>
<p>​      <strong>要求是顺序表，分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</strong> </p>
<h4 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h4><p>​    <strong>将n个数据元素”按块有序”划分为m块（m ≤ n）。</strong>    <strong>每一块中的结点不必有序，但块与块之间必须”按块有序”；</strong>    <strong>即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；</strong>    <strong>而第2块中任一元素又都必须小于第3块中的任一元素，……</strong></p>
<p><strong><img src="https://img-blog.csdn.net/2018071013331917?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4MzI4Mzc4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></strong></p>
<p><strong>算法流程</strong>　</p>
<p>​    <strong>1、先选取各块中的最大关键字构成一个索引表；    2、查找分两个部分：先对索引表进行二分查找或顺序查找，以确定待查记录在哪一块中；    3、在已确定的块中用顺序法进行查找。</strong></p>
<h4 id="复杂度分析-5"><a href="#复杂度分析-5" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>​    <strong>时间复杂度：O(log(m)+N/m)</strong></p>
<h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><h4 id="算法简介-1"><a href="#算法简介-1" class="headerlink" title="算法简介"></a>算法简介</h4><p>   <strong>哈希表就是一种以键-值(key-indexed) 存储数据的结构，只要输入待查找的值即key，即可查找到其对应的值。</strong></p>
<h4 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a><strong>算法思想</strong></h4><p>​    <strong>哈希的思路很简单，如果所有的键都是整数，那么就可以使用一个简单的无序数组来实现：将键作为索引，值即为其对应的值，这样就可以快速访问任意键的值。这是对于简单的键的情况，我们将其扩展到可以处理更加复杂的类型的键。</strong></p>
<p><strong>算法流程</strong></p>
<p>　　<strong>1）用给定的哈希函数构造哈希表；　　2）根据选择的冲突处理方法解决地址冲突；　　　　 常见的解决冲突的方法：拉链法和线性探测法。　　3）在哈希表的基础上执行哈希查找。</strong></p>
<h4 id="复杂度分析-6"><a href="#复杂度分析-6" class="headerlink" title="复杂度分析"></a><strong>复杂度分析</strong></h4><p>　　<strong>单纯论查找复杂度：对于无冲突的Hash表而言，查找复杂度为O(1)（注意，在查找之前我们需要构建相应的Hash表）。</strong></p>
<h4 id="算法实现-8"><a href="#算法实现-8" class="headerlink" title="算法实现"></a>算法实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"># 忽略了对数据类型，元素溢出等问题的判断。</span><br><span class="line"> </span><br><span class="line">class HashTable:</span><br><span class="line">  def __init__(self, size):</span><br><span class="line">    self.elem = [None for i in range(size)] # 使用list数据结构作为哈希表元素保存方法</span><br><span class="line">    self.count = size # 最大表长</span><br><span class="line"> </span><br><span class="line">  def hash(self, key):</span><br><span class="line">    return key % self.count # 散列函数采用除留余数法</span><br><span class="line"> </span><br><span class="line">  def insert_hash(self, key):</span><br><span class="line">    &quot;&quot;&quot;插入关键字到哈希表内&quot;&quot;&quot;</span><br><span class="line">    address = self.hash(key) # 求散列地址</span><br><span class="line">    while self.elem[address]: # 当前位置已经有数据了，发生冲突。</span><br><span class="line">      address = (address+1) % self.count # 线性探测下一地址是否可用</span><br><span class="line">    self.elem[address] = key # 没有冲突则直接保存。</span><br><span class="line"> </span><br><span class="line">  def search_hash(self, key):</span><br><span class="line">    &quot;&quot;&quot;查找关键字，返回布尔值&quot;&quot;&quot;</span><br><span class="line">    star = address = self.hash(key)</span><br><span class="line">    while self.elem[address] != key:</span><br><span class="line">      address = (address + 1) % self.count</span><br><span class="line">      if not self.elem[address] or address == star: # 说明没找到或者循环到了开始的位置</span><br><span class="line">        return False</span><br><span class="line">    return True</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">  list_a = [12, 67, 56, 16, 25, 37, 22, 29, 15, 47, 48, 34]</span><br><span class="line">  hash_table = HashTable(12)</span><br><span class="line">  for i in list_a:</span><br><span class="line">    hash_table.insert_hash(i)</span><br><span class="line"> </span><br><span class="line">  for i in hash_table.elem:</span><br><span class="line">    if i:</span><br><span class="line">      print((i, hash_table.elem.index(i)), end=&quot; &quot;)</span><br><span class="line">  print(&quot;\n&quot;)</span><br><span class="line"> </span><br><span class="line">  print(hash_table.search_hash(15))</span><br><span class="line">  print(hash_table.search_hash(33))</span><br></pre></td></tr></table></figure>
</article>

    <div class="pagenator post-pagenator">
    
    
        <a class="extend prev post-prev" href="/2015/09/22/myarticle4/">prev</a>
    

    
    <p>last update time 2019-09-03</p>
    
    
        <a class="extend next post-next" href="/2015/09/15/myarticle2/">next</a>
    
    </div>

    </div>
    <div class="footer">
        <div class="container">
    <div class="social">
	<ul class="social-list">
		
			
				
				
				<li>
					<a href="mailto:1178752402@qq.com" title="email" target="_blank">
					<i class="fa fa-email"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://github.com/CaiChenghan" title="github" target="_self">
					<i class="fa fa-github"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
			
				
				<li>
					<a href="https://www.jianshu.com/u/565c8e790605" title="jianshu" target="_self">
					<i class="fa fa-jianshu"></i>
					</a>
				</li>
			
		
			
		
			
		
			
		
	</ul>
</div>
    <div class="copyright">
        <span>
            
            
            
                © 小飞 2017 - 2019
            
        </span>
    </div>
    <div class="power">
        <span>
            Powered by <a href="https://hexo.io">Hexo</a> & <a href="https://github.com/CaiChenghan/iLiKE">iLiKE Theme</a>
        </span>
    </div>
    <script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></script>
    <!--page counter part-->
<script>
function addCount (Counter) {
    url=$('.article-date').attr('href').trim();
    title = $('.article-title').text().trim();
    var query = new AV.Query(Counter);
    //use url as unique idnetfication
    query.equalTo("url",url);
    query.find({
        success: function(results) {
            if (results.length>0) {
                var counter=results[0];
                counter.fetchWhenSave(true); //get recent result
                counter.increment("time");
                counter.save();
            } else {
                var newcounter=new Counter();
                newcounter.set("title",title);
                newcounter.set("url",url);
                newcounter.set("time",1);
                newcounter.save(null,{
                    success: function(newcounter) {
                        //alert('New object created');
                    }, error: function(newcounter,error) {
                        alert('Failed to create');
                    }
                })
            }
        },
        error: function(error) {
            //find null is not a error
            alert('Error:'+error.code+" "+error.message);
        }
    });
}
$(function() {
    var Counter=AV.Object.extend("Counter");
    //only increse visit counting when intering a page
    if ($('.article-title').length == 1) {
       addCount(Counter);
    }
    var query=new AV.Query(Counter);
    query.descending("time");
    // the sum of popular posts
    query.limit(10); 
    query.find({
        success: function(results) {
                for(var i=0;i<results.length;i++) {
                    var counter=results[i];
                    title=counter.get("title");
                    url=counter.get("url");
                    time=counter.get("time");
                    // add to the popularlist widget
                    showcontent=title+" ("+time+")";
                    //notice the "" in href
                    $('.popularlist').append('<li><a href="'+url+'">'+showcontent+'</a></li>');
                }
            },
        error: function(error) {
            alert("Error:"+error.code+" "+error.message);
        }
    });
});
</script>
</div>
    </div>
</body>
</html>
